[
  {
    "id": 1,
    "chapter": "第1章 绪论",
    "question": "可以用( ) 定义一个完整的数据结构。",
    "options": [
      {
        "label": "A",
        "text": "数据元素"
      },
      {
        "label": "B",
        "text": "数据对象"
      },
      {
        "label": "C",
        "text": "数据关系"
      },
      {
        "label": "D",
        "text": "抽象数据类型"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 2,
    "chapter": "第1章 绪论",
    "question": "以下数据结构中, ( ) 是非线性数据结构。",
    "options": [
      {
        "label": "A",
        "text": "树"
      },
      {
        "label": "B",
        "text": "字符串"
      },
      {
        "label": "C",
        "text": "队列"
      },
      {
        "label": "D",
        "text": "栈"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 3,
    "chapter": "第1章 绪论",
    "question": "以下属于逻辑结构的是( )",
    "options": [
      {
        "label": "A",
        "text": "顺序表"
      },
      {
        "label": "B",
        "text": "哈希表"
      },
      {
        "label": "C",
        "text": "有序表"
      },
      {
        "label": "D",
        "text": "单链表"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 4,
    "chapter": "第1章 绪论",
    "question": "以下关于数据结构的说法中, 正确的是( )",
    "options": [
      {
        "label": "A",
        "text": "数据的逻辑结构独立于其存储结构"
      },
      {
        "label": "B",
        "text": "数据的存储结构独立于其逻辑结构"
      },
      {
        "label": "C",
        "text": "数据的逻辑结构唯一决定其存储结构"
      },
      {
        "label": "D",
        "text": "数据结构仅由其逻辑结构和存储结构决定"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 5,
    "chapter": "第1章 绪论",
    "question": "在存储数据时,通常不仅要存储各数据元素的值,而且要存储( )",
    "options": [
      {
        "label": "A",
        "text": "数据的操作方法"
      },
      {
        "label": "B",
        "text": "数据元素的类型"
      },
      {
        "label": "C",
        "text": "数据元素之间的关系"
      },
      {
        "label": "D",
        "text": "数据的存取方法"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 6,
    "chapter": "第1章 绪论",
    "question": "一个算法应该具有( ) 等重要特性。 B. 可行性、确定性和有穷性D. 可读性、正确性和可行性",
    "options": [
      {
        "label": "A",
        "text": "可维护性、可读性和可行性C. 确定性、有穷性和可靠性 2. 下列关于算法的说法中, 正确的是( ) A. 算法的时间效率取决于算法执行所花的CPU 时间"
      },
      {
        "label": "B",
        "text": "在算法设计中不允许用牺牲空间效率的方式来换取好的时间效率"
      },
      {
        "label": "C",
        "text": "算法必须具备有穷性、确定性等五个特性"
      },
      {
        "label": "D",
        "text": "通常用时间效率和空间效率来衡量算法的优劣"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 7,
    "chapter": "第1章 绪论",
    "question": "某算法的时间复杂度为O n2 , 表明该算法的( )",
    "options": [
      {
        "label": "A",
        "text": "问题规模是n2"
      },
      {
        "label": "B",
        "text": "执行时间等于n2"
      },
      {
        "label": "C",
        "text": "执行时间与n2成正比"
      },
      {
        "label": "D",
        "text": "问题规模与n2成正比"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 8,
    "chapter": "第1章 绪论",
    "question": "若某算法的空间复杂度为O 1 , 则表示该算法( )",
    "options": [
      {
        "label": "A",
        "text": "不需要任何辅助空间"
      },
      {
        "label": "B",
        "text": "所需辅助空间大小与问题规模n 无关"
      },
      {
        "label": "C",
        "text": "不需要任何空间"
      },
      {
        "label": "D",
        "text": "所需空间大小与问题规模n 无关"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 9,
    "chapter": "第1章 绪论",
    "question": "下列关于时间复杂度的函数中, 时间复杂度最小的是( )",
    "options": [
      {
        "label": "A",
        "text": "T1 n = nlog2n + 5000n"
      },
      {
        "label": "B",
        "text": "T2 n = n2- 8000n"
      },
      {
        "label": "C",
        "text": "T3 n = nlog2n - 6000n"
      },
      {
        "label": "D",
        "text": "T4 n = 20000log2n"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 10,
    "chapter": "第1章 绪论",
    "question": "以下算法的时间复杂度为( )",
    "options": [
      {
        "label": "A",
        "text": "O n"
      },
      {
        "label": "B",
        "text": "O n2 )"
      },
      {
        "label": "C",
        "text": "O nlog2n"
      },
      {
        "label": "D",
        "text": " log2n"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 11,
    "chapter": "第1章 绪论",
    "question": "有以下算法,其时间复杂度为(",
    "options": [
      {
        "label": "A",
        "text": "O n"
      },
      {
        "label": "B",
        "text": "O nlog2n"
      },
      {
        "label": "C",
        "text": "O  3 n"
      },
      {
        "label": "D",
        "text": "O n"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 12,
    "chapter": "第1章 绪论",
    "question": "程序段如下: 其中n 为正整数, 则最后一行语句的频度在最坏情况下是( ) D. O n2",
    "options": [
      {
        "label": "A",
        "text": "O n"
      },
      {
        "label": "B",
        "text": "O nlog2n"
      },
      {
        "label": "C",
        "text": "O n3 9. 下列程序段的时间复杂度为( ) A. O n2 B. O n C. O 1"
      },
      {
        "label": "D",
        "text": "O nlog2n"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 13,
    "chapter": "第1章 绪论",
    "question": "以下算法中加下画线的语句的执行次数为( )",
    "options": [
      {
        "label": "A",
        "text": "n n+1"
      },
      {
        "label": "B",
        "text": "n )"
      },
      {
        "label": "C",
        "text": "n + 1"
      },
      {
        "label": "D",
        "text": "n2"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 14,
    "chapter": "第1章 绪论",
    "question": "下列函数代码的时间复杂度是(",
    "options": [
      {
        "label": "A",
        "text": "O n"
      },
      {
        "label": "B",
        "text": "O nlog2n"
      },
      {
        "label": "C",
        "text": "O log2n"
      },
      {
        "label": "D",
        "text": "O n2 12.【2011 统考真题】设n 是描述问题规模的非负整数, 下面的程序片段的时间复杂度是( ) A. O log2n B. O n C. O nlog2n D. O n2 13.【2012 统考真题】求整数n n≥0 的阶乘的算法如下, 其时间复杂度是( ) A. O log2n B. O n C. O nlog2n D. O n2 14.【2014 统考真题】下列程序段的时间复杂度是( ) A. O log2n B. O n C. O nlog2n D. O n2"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 15,
    "chapter": "第1章 绪论",
    "question": "下列函数的时间复杂度是( )",
    "options": [
      {
        "label": "A",
        "text": "O log2n"
      },
      {
        "label": "B",
        "text": "O n"
      },
      {
        "label": "C",
        "text": "O n"
      },
      {
        "label": "D",
        "text": "O nlog2n 16.【2019 统考真题】设n 是描述问题规模的非负整数, 下列程序段的时间复杂度是( ) A. O log2n B. O n C. O n D. O n2 17.【2022 统考真题】下列程序段的时间复杂度是( ) A. O log2n B. O n C. O nlog2n D. O n2"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 16,
    "chapter": "第2章 线性表",
    "question": "线性表是具有n 个( ) 的有限序列。",
    "options": [
      {
        "label": "A",
        "text": "数据表"
      },
      {
        "label": "B",
        "text": "字符"
      },
      {
        "label": "C",
        "text": "数据元素"
      },
      {
        "label": "D",
        "text": "数据项"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 17,
    "chapter": "第2章 线性表",
    "question": "下列几种描述中, ( ) 是一个线性表。",
    "options": [
      {
        "label": "A",
        "text": "由n 个实数组成的集合"
      },
      {
        "label": "B",
        "text": "由100 个字符组成的序列"
      },
      {
        "label": "C",
        "text": "所有整数组成的序列"
      },
      {
        "label": "D",
        "text": "邻接表"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 18,
    "chapter": "第2章 线性表",
    "question": "[图片] 在线性表中,除开始元素外,每个元素( )",
    "options": [
      {
        "label": "A",
        "text": "只有唯一的前驱元素"
      },
      {
        "label": "B",
        "text": "只有唯一的后继元素"
      },
      {
        "label": "C",
        "text": "有多个前驱元素"
      },
      {
        "label": "D",
        "text": "有多个后继元素"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 19,
    "chapter": "第2章 线性表",
    "question": "[图片] 若非空线性表中的元素既没有直接前驱, 又没有直接后继, 则该表中有( ) 个元素。",
    "options": [
      {
        "label": "A",
        "text": "1"
      },
      {
        "label": "B",
        "text": "2"
      },
      {
        "label": "C",
        "text": "3"
      },
      {
        "label": "D",
        "text": "n"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 20,
    "chapter": "第2章 线性表",
    "question": "下列叙述中, ( ) 是顺序存储结构的优点。 B. 插入运算方便D. 方便地运用于各种逻辑结构的存储表示",
    "options": [
      {
        "label": "A",
        "text": "存储密度大C. 删除运算方便 2. 下列关于顺序表的叙述中,正确的是( ) A. 顺序表可以利用一维数组表示,因此顺序表与一维数组在逻辑结构上是相同的"
      },
      {
        "label": "B",
        "text": "在顺序表中,逻辑上相邻的元素物理位置上不一定相邻"
      },
      {
        "label": "C",
        "text": "顺序表和一维数组一样,都可以进行随机存取"
      },
      {
        "label": "D",
        "text": "在顺序表中,每个元素的类型不必相同"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 21,
    "chapter": "第2章 线性表",
    "question": "线性表的顺序存储结构是一种( ) B. 顺序存取的存储结构D. 散列存取的存储结构 )",
    "options": [
      {
        "label": "A",
        "text": "随机存取的存储结构C. 索引存取的存储结构 4. 通常说顺序表具有随机存取的特性, 指的是( A. 查找值为x 的元素的时间与顺序表中元素个数n 无关"
      },
      {
        "label": "B",
        "text": "查找值为x 的元素的时间与顺序表中元素个数n 有关"
      },
      {
        "label": "C",
        "text": "查找序号为i 的元素的时间与顺序表中元素个数n 无关"
      },
      {
        "label": "D",
        "text": "查找序号为i 的元素的时间与顺序表中元素个数n 有关"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 22,
    "chapter": "第2章 线性表",
    "question": "一个顺序表所占用的存储空间大小与( ) 无关。 D. 元素中各字段的类型",
    "options": [
      {
        "label": "A",
        "text": "表的长度"
      },
      {
        "label": "B",
        "text": "元素的存放顺序"
      },
      {
        "label": "C",
        "text": "元素的类型    6. 若线性表最常用的操作是存取第i 个元素及其前驱和后继元素的值, 为了提高效率, 应采用( ) 的 存储方式。 A. 单链表 B. 双向链表 C. 循环单链表"
      },
      {
        "label": "D",
        "text": "顺序表"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 23,
    "chapter": "第2章 线性表",
    "question": "一个线性表最常用的操作是存取任意一个指定序号的元素并在最后进行插入、删除操作,则利用 ( ) 存储方式可以节省时间。 )",
    "options": [
      {
        "label": "A",
        "text": "顺序表"
      },
      {
        "label": "B",
        "text": "双链表"
      },
      {
        "label": "C",
        "text": "带头结点的循环双链表"
      },
      {
        "label": "D",
        "text": "循环单链表"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 24,
    "chapter": "第2章 线性表",
    "question": "在n 个元素的线性表的数组表示中, 时间复杂度为O 1 的操作是( I.访问第i 1≤i≤n 个结点和求第i 2≤i≤n 个结点的直接前驱 II.在最后一个结点后插入一个新的结点 III.删除第1 个结点 IV.在第i 1≤i≤n 个结点后插入一个结点",
    "options": [
      {
        "label": "A",
        "text": "I"
      },
      {
        "label": "B",
        "text": "II、III"
      },
      {
        "label": "C",
        "text": "I、II"
      },
      {
        "label": "D",
        "text": "I、II、III"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 25,
    "chapter": "第2章 线性表",
    "question": "设线性表有n 个元素, 严格说来, 以下操作中,( ) 在顺序表上实现要比在链表上实现的效率高。 I.输出第i 1≤i≤n 个元素值 II.交换第3 个元素与第4 个元素的值 III.顺序输出这n 个元素的值",
    "options": [
      {
        "label": "A",
        "text": "I"
      },
      {
        "label": "B",
        "text": "I、III"
      },
      {
        "label": "C",
        "text": "I、II"
      },
      {
        "label": "D",
        "text": "II、III"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 26,
    "chapter": "第2章 线性表",
    "question": "[图片] 在一个长度为n 的顺序表中删除第i 1≤i≤n 个元素时, 需向前移动() 个元素。",
    "options": [
      {
        "label": "A",
        "text": "n"
      },
      {
        "label": "B",
        "text": "i - 1"
      },
      {
        "label": "C",
        "text": "n - i"
      },
      {
        "label": "D",
        "text": "n - i + 1"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 27,
    "chapter": "第2章 线性表",
    "question": "对于顺序表, 访问第i 个位置的元素和在第i 个位置插入一个元素的时间复杂度为( )",
    "options": [
      {
        "label": "A",
        "text": "O n ,O n"
      },
      {
        "label": "B",
        "text": "O n ,O 1"
      },
      {
        "label": "C",
        "text": "O 1 ,O n"
      },
      {
        "label": "D",
        "text": "O 1 ,O 1"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 28,
    "chapter": "第2章 线性表",
    "question": "对于顺序存储的线性表, 其算法时间复杂度为O 1 的运算应该是( )",
    "options": [
      {
        "label": "A",
        "text": "将n 个元素从小到大排序"
      },
      {
        "label": "B",
        "text": "删除第i 1≤i≤n 个元素"
      },
      {
        "label": "C",
        "text": "改变第i 1≤i≤n 个元素的值"
      },
      {
        "label": "D",
        "text": "在第i 1≤i≤n 个元素后插入一个新元素"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 29,
    "chapter": "第2章 线性表",
    "question": "若长度为n 的非空线性表采用顺序存储结构, 在表的第i 个位置插入一个数据元素, 则i 的合法值 应该是( ) B. 1 ≤i ≤n + 1 C. 1 ≤i ≤n - 1 D. 0 ≤i ≤n",
    "options": [
      {
        "label": "A",
        "text": "1 ≤i ≤n 14. 顺序表的插入算法中, 当n 个空间已满时, 可再申请增加分配m 个空间, 若申请失败, 则说明系统 没有( ) 可分配的存储空间。 C. n + m 个 D. n + m 个连续 A. m 个"
      },
      {
        "label": "B",
        "text": "m 个连续    15.【2023 统考真题】在下列对顺序存储的有序表(长度为n) 实现给定操作的算法中, 平均时间复杂度为O 1 的是( ) A. 查找包含指定值元素的算法 B. 插入包含指定值元素的算法"
      },
      {
        "label": "C",
        "text": "删除第i 1≤i≤n 个元素的算法"
      },
      {
        "label": "D",
        "text": "获取第i 1≤i≤n个元素的算法"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 30,
    "chapter": "第2章 线性表",
    "question": "下列关于线性表的存储结构的描述中,正确的是( ) I.线性表的顺序存储结构优于其链式存储结构II.链式存储结构比顺序存储结构能更方便地表示各种逻辑结构III.若频繁使用插入和删除结点操作, 则顺序存储结构更优于链式存储结构IV.顺序存储结构和链式存储结构都可以进行顺序存取",
    "options": [
      {
        "label": "A",
        "text": "I、II、III"
      },
      {
        "label": "B",
        "text": "II、IV"
      },
      {
        "label": "C",
        "text": "II、III"
      },
      {
        "label": "D",
        "text": "III、IV"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 31,
    "chapter": "第2章 线性表",
    "question": "对于一个线性表,既要求能够进行较快速地插入和删除,又要求存储结构能反映数据之间的逻辑关 系,则应该用( ) C. 散列存储方式 D. 以上均可以",
    "options": [
      {
        "label": "A",
        "text": "顺序存储方式"
      },
      {
        "label": "B",
        "text": "链式存储方式 3. 链式存储设计时, 结点内的存储单元地址( ) D. 部分连续,部分不连续 A. 一定连续 B. 一定不连续"
      },
      {
        "label": "C",
        "text": "不一定连续 4. 下列关于线性表说法中, 正确的是( ) I.顺序存储方式只能用于存储线性结构II.在一个设有头指针和尾指针的单链表中, 删除表尾元素的时间复杂度与表长无关III.带头结点的循环单链表中不存在空指针IV.在一个长度为n 的有序单链表中插入一个新结点并仍保持有序的时间复杂度为O n V.若用单链表来表示队列,则应该选用带尾指针的循环链表 A. I、II B. I、III、IV、V C. IV、V"
      },
      {
        "label": "D",
        "text": "III、IV、V"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 32,
    "chapter": "第2章 线性表",
    "question": "[图片] 设线性表中有2n 个元素,( ) 在单链表上实现要比在顺序表上实现效率更高。",
    "options": [
      {
        "label": "A",
        "text": "删除所有值为x 的元素"
      },
      {
        "label": "B",
        "text": "在最后一个元素的后面插入一个新元素"
      },
      {
        "label": "C",
        "text": "顺序输出前k 个元素"
      },
      {
        "label": "D",
        "text": "交换第i 个元素和第2n - i - 1 个元素的值i=0,⋯,n-1"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 33,
    "chapter": "第2章 线性表",
    "question": "[图片] 在一个单链表中, 已知q 所指结点是p 所指结点的前驱结点, 若在q 和p 之间插入结点s, 则执行( )",
    "options": [
      {
        "label": "A",
        "text": "s -> next = p -> next;p -> next = s; C. q -> next = s;s -> next = p;"
      },
      {
        "label": "B",
        "text": "p -> next = s -> next;s -> next = p; D. p -> next = s;s -> next = q;    7. 给定有n 个元素的一维数组, 建立一个有序单链表的最低时间复杂度是( ) A. O 1 B. O n"
      },
      {
        "label": "C",
        "text": "O n2"
      },
      {
        "label": "D",
        "text": "O nlog2n"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 34,
    "chapter": "第2章 线性表",
    "question": "将长度为n 的单链表链接在长度为m 的单链表后面, 其算法的时间复杂度采用大O 形式表示应该 是( )",
    "options": [
      {
        "label": "A",
        "text": "O 1"
      },
      {
        "label": "B",
        "text": "O n"
      },
      {
        "label": "C",
        "text": "O m"
      },
      {
        "label": "D",
        "text": "O n+m"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 35,
    "chapter": "第2章 线性表",
    "question": "[图片] 单链表中, 增加一个头结点的目的是( )",
    "options": [
      {
        "label": "A",
        "text": "使单链表至少有一个结点"
      },
      {
        "label": "B",
        "text": "标识表结点中首结点的位置"
      },
      {
        "label": "C",
        "text": "方便运算的实现"
      },
      {
        "label": "D",
        "text": "说明单链表是线性表的链式存储"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 36,
    "chapter": "第2章 线性表",
    "question": "在一个长度为n 的带头结点的单链表h 上, 设有尾指针r, 则执行( ) 操作与链表的表长有关。",
    "options": [
      {
        "label": "A",
        "text": "删除单链表中的第一个元素"
      },
      {
        "label": "B",
        "text": "删除单链表中的最后一个元素"
      },
      {
        "label": "C",
        "text": "在单链表第一个元素前插入一个新元素"
      },
      {
        "label": "D",
        "text": "在单链表最后一个元素后插入一个新元素"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 37,
    "chapter": "第2章 线性表",
    "question": "对于一个头指针为head 的带头结点的单链表, 判定该表为空表的条件是( ); 对于不带头结点的 单链表,判定空表的条件为( )",
    "options": [
      {
        "label": "A",
        "text": "head == NULL"
      },
      {
        "label": "B",
        "text": "head -> next == NULL"
      },
      {
        "label": "C",
        "text": "head -> next == head"
      },
      {
        "label": "D",
        "text": "head! = NULL"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 38,
    "chapter": "第2章 线性表",
    "question": "[图片] 在线性表中a0,a1, ⋯,a100, 删除元素a50 需要移动( ) 个元素。",
    "options": [
      {
        "label": "A",
        "text": "0"
      },
      {
        "label": "B",
        "text": "50"
      },
      {
        "label": "C",
        "text": "51"
      },
      {
        "label": "D",
        "text": "0 或50"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 39,
    "chapter": "第2章 线性表",
    "question": "通过含有n n>1 个元素的数组a, 采用头插法建立单链表L, 则L 中的元素次序( )",
    "options": [
      {
        "label": "A",
        "text": "与数组a 的元素次序相同"
      },
      {
        "label": "B",
        "text": "与数组a 的元素次序相反"
      },
      {
        "label": "C",
        "text": "与数组a 的元素次序无关"
      },
      {
        "label": "D",
        "text": "以上都错误"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 40,
    "chapter": "第2章 线性表",
    "question": "下面关于线性表的一些说法中, 正确的是( )",
    "options": [
      {
        "label": "A",
        "text": "对一个设有头指针和尾指针的单链表执行删除最后一个元素的操作与链表长度无关"
      },
      {
        "label": "B",
        "text": "线性表中每个元素都有一个直接前驱和一个直接后继"
      },
      {
        "label": "C",
        "text": "为了方便插入和删除数据,可以使用双链表存放数据"
      },
      {
        "label": "D",
        "text": "取线性表第i 个元素的时间与i 的大小有关"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 41,
    "chapter": "第2章 线性表",
    "question": "[图片] 在双链表中向p 所指的结点之前插入一个结点q 的操作为( )",
    "options": [
      {
        "label": "A",
        "text": "p -> prior = q;q -> next = p;p -> prior -> next = q;q -> prior = p -> prior;"
      },
      {
        "label": "B",
        "text": "q -> prior = p -> prior;p -> prior -> next = q;q -> next = p;p -> prior = q -> next;"
      },
      {
        "label": "C",
        "text": "q -> next = p;p -> next = q;q -> prior -> next = q;q -> next = p;"
      },
      {
        "label": "D",
        "text": "p -> prior -> next = q;q -> next = p;q -> prior = p -> prior;p -> prior = q;"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 42,
    "chapter": "第2章 线性表",
    "question": "在双向链表存储结构中, 删除p 所指的结点时必须修改指针( )",
    "options": [
      {
        "label": "A",
        "text": "p -> prior -> next = p -> next;p -> next -> prior = p -> prior;"
      },
      {
        "label": "B",
        "text": "p -> prior = p -> prior -> prior;p -> prior -> next = p;"
      },
      {
        "label": "C",
        "text": "p -> next -> prior = p;p -> next = p -> next -> next;"
      },
      {
        "label": "D",
        "text": "p -> next = p -> prior -> prior;p -> prior = p -> next -> next;"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 43,
    "chapter": "第2章 线性表",
    "question": "[图片] 在如下图所示的双链表中, 已知指针p 指向结点A, 若要在结点A 和C 之间插入指针q 所指的结 点B,则依次执行的语句序列可以是( ) ①q -> next = p -> next; ②q -> prior = p; ③p -> next = q; ④p -> next -> prior = q;",
    "options": [
      {
        "label": "A",
        "text": "①②④③"
      },
      {
        "label": "B",
        "text": "④③②①"
      },
      {
        "label": "C",
        "text": "③④①②"
      },
      {
        "label": "D",
        "text": "①③④②"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 44,
    "chapter": "第2章 线性表",
    "question": "在双链表的两个结点之间插入一个新结点,需要修改( ) 个指针域。",
    "options": [
      {
        "label": "A",
        "text": "1"
      },
      {
        "label": "B",
        "text": "3"
      },
      {
        "label": "C",
        "text": "4"
      },
      {
        "label": "D",
        "text": "2"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 45,
    "chapter": "第2章 线性表",
    "question": "[图片] 在长度为n 的有序单链表中插入一个新结点, 并仍然保持有序的时间复杂度是( )",
    "options": [
      {
        "label": "A",
        "text": "O 1"
      },
      {
        "label": "B",
        "text": "O n"
      },
      {
        "label": "C",
        "text": "O n2"
      },
      {
        "label": "D",
        "text": "O nlog2n"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 46,
    "chapter": "第2章 线性表",
    "question": "与单链表相比,双链表的优点之一是( )",
    "options": [
      {
        "label": "A",
        "text": "插入、删除操作更方便"
      },
      {
        "label": "B",
        "text": "可以进行随机访问"
      },
      {
        "label": "C",
        "text": "可以省略表头指针或表尾指针"
      },
      {
        "label": "D",
        "text": "访问前后相邻结点更灵活"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 47,
    "chapter": "第2章 线性表",
    "question": "对于一个带头结点的循环单链表L,判断该表为空表的条件是( )",
    "options": [
      {
        "label": "A",
        "text": "头结点的指针域为空"
      },
      {
        "label": "B",
        "text": "L 的值为NULL"
      },
      {
        "label": "C",
        "text": "头结点的指针域与L 的值相等"
      },
      {
        "label": "D",
        "text": "头结点的指针域与L 的地址相等"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 48,
    "chapter": "第2章 线性表",
    "question": "对于一个带头结点的循环双链表L,判断该表为空表的条件是( )",
    "options": [
      {
        "label": "A",
        "text": "L -> prior == Lamp;amp;L -> next == NULL"
      },
      {
        "label": "B",
        "text": "L -> prior == NULLamp;amp;L -> next == NULL"
      },
      {
        "label": "C",
        "text": "L -> prior == NULLamp;amp;L -> next == L"
      },
      {
        "label": "D",
        "text": "L -> prior == Lamp;amp;L -> next == L"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 49,
    "chapter": "第2章 线性表",
    "question": "一个链表最常用的操作是在末尾插入结点和删除结点,则选用( ) 最节省时间。",
    "options": [
      {
        "label": "A",
        "text": "带头结点的循环双链表"
      },
      {
        "label": "B",
        "text": "循环单链表"
      },
      {
        "label": "C",
        "text": "带尾指针的循环单链表"
      },
      {
        "label": "D",
        "text": "单链表"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 50,
    "chapter": "第2章 线性表",
    "question": "设对n n>1 个元素的线性表的运算只有4 种: 删除第一个元素; 删除最后一个元素; 在第一个元 素之前插入新元素；在最后一个元素之后插入新元素, 则最好使用( )",
    "options": [
      {
        "label": "A",
        "text": "只有尾结点指针没有头结点指针的循环单链表"
      },
      {
        "label": "B",
        "text": "只有尾结点指针没有头结点指针的非循环双链表"
      },
      {
        "label": "C",
        "text": "只有头结点指针没有尾结点指针的循环双链表"
      },
      {
        "label": "D",
        "text": "既有头结点指针又有尾结点指针的循环单链表"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 51,
    "chapter": "第2章 线性表",
    "question": "设有两个长度为n 的循环单链表, 若要求两个循环单链表的头尾相接的时间复杂度为O 1 , 则对 应两个循环单链表各设置一个指针, 分别指向( )",
    "options": [
      {
        "label": "A",
        "text": "各自的头结点"
      },
      {
        "label": "B",
        "text": "各自的尾结点"
      },
      {
        "label": "C",
        "text": "各自的首结点"
      },
      {
        "label": "D",
        "text": "一个表的头结点,另一个表的尾结点"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 52,
    "chapter": "第2章 线性表",
    "question": "[图片] 设有一个长度为n 的循环单链表, 若从表中删除首元结点的时间复杂度达到O n , 则此时采用的 循环单链表的结构可能是( )",
    "options": [
      {
        "label": "A",
        "text": "只有表头指针, 没有头结点"
      },
      {
        "label": "B",
        "text": "只有表尾指针,没有头结点"
      },
      {
        "label": "C",
        "text": "只有表尾指针,带头结点"
      },
      {
        "label": "D",
        "text": "只有表头指针,带头结点"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 53,
    "chapter": "第2章 线性表",
    "question": "某线性表用带头结点的循环单链表存储, 头指针为head, 当head -> next -> next == head 成立 时, 线性表的长度可能是( ) C. 2 D. 可能为0 或1",
    "options": [
      {
        "label": "A",
        "text": "0"
      },
      {
        "label": "B",
        "text": "1 28. 有两个长度都为n 的双链表, 若以h1 为头指针的双链表是非循环的, 以h2 为头指针的双链表是循环的,则下列叙述中正确的是( ) A. 对于双链表h1, 删除首结点的时间复杂度是O n B. 对于双链表h2, 删除首结点的时间复杂度是O n"
      },
      {
        "label": "C",
        "text": "对于双链表h1, 删除尾结点的时间复杂度是O 1"
      },
      {
        "label": "D",
        "text": "对于双链表h2, 删除尾结点的时间复杂度是O 1"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 54,
    "chapter": "第2章 线性表",
    "question": "一个链表最常用的操作是在最后一个元素后插入一个元素和删除第一个元素,则选用( ) 最节省时间。",
    "options": [
      {
        "label": "A",
        "text": "不带头结点的循环单链表"
      },
      {
        "label": "B",
        "text": "双链表"
      },
      {
        "label": "C",
        "text": "单链表"
      },
      {
        "label": "D",
        "text": "不带头结点且有尾指针的循环单链表"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 55,
    "chapter": "第2章 线性表",
    "question": "需要分配较大空间,插入和删除不需要移动元素的线性表,其存储结构为( )",
    "options": [
      {
        "label": "A",
        "text": "单链表"
      },
      {
        "label": "B",
        "text": "静态链表"
      },
      {
        "label": "C",
        "text": "顺序表"
      },
      {
        "label": "D",
        "text": "双链表"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 56,
    "chapter": "第2章 线性表",
    "question": "[图片] 下列关于静态链表的说法中, 正确的是( ) I.静态链表兼具顺序表和单链表的优点, 因此存取表中第i 个元素的时间与i 无关II.静态链表能容纳的最大元素个数在表定义时就确定了,以后不能增加III.静态链表与动态链表在元素的插入、删除上类似,不需要移动元素IV.相比动态链表,静态链表可能浪费较多的存储空间",
    "options": [
      {
        "label": "A",
        "text": "I、II、III"
      },
      {
        "label": "B",
        "text": "II、III、IV"
      },
      {
        "label": "C",
        "text": "I、II、IV"
      },
      {
        "label": "D",
        "text": "I、II、IV 32.【2016 统考真题】已知一个带有表头结点的循环双链表L, 结点结构为: prev data next 其中prev 和next 分别是指向其直接前驱和直接后继结点的指针。现要删除指针p 所指的结点, 正确的语句序列是( ) A. p -> next -> prev = p -> prev;p -> prev -> next = p -> prev;free(p); B. p -> next -> prev = p -> next;p -> prev -> next = p -> next;free(p); C. p -> next -> prev = p -> next;p -> prev -> next = p -> prev;free(p); D. p -> next -> prev = p -> prev;p -> prev -> next = p -> next;free(p); 33.【2016 统考真题】已知表头元素为c 的单链表在内存中的存储状态如下表所示: 地址 元素 链接地址 1000H a 1010H 1004H b 100CH 1008H c 1000H 100CH d NULL 1010H e 1004H 1014H 现将f 存放于1014H 处并插入单链表, 若f 在逻辑上位于a 和e 之间, 则a,e,f 的“链接地址”依次是( ) A. 1010H,1014H,1004H B. 1010H,1004H,1014H C. 1014H,1010H,1004H D. 1014H,1004H,1010H 34.【2021 统考真题】已知头指针h 指向一个带头结点的非空循环单链表, 结点结构为: data next 其中next 是指向直接后继结点的指针, p 是尾指针, q 是临时指针。现要删除该链表的第一个元素, 正确的语句序列是( ) A. h -> next = h -> next -> next;q = h -> next;free(q); B. q = h -> next;h -> next = h -> next -> next;free(q); C. q = h -> next;h -> next = q -> next;if p!=q D. q = h -> next;h -> next = q -> next;if p==q p = h;free(q); p = h;free(q);    35.【2023 统考真题】现有非空双链表L,其结点结构为: prev data next prev 是指向直接前驱结点的指针, next 是指向直接后继结点的指针。若要在L 中指针p 所指向的结点(非尾结点) 之后插入指针s 指向的新结点, 则在执行语句序列“s -> next = p -> next;p -> next = s;”后, 下列语句序列中还需要执行的是( ) A. s -> next -> prev = p;s -> prev = p; B. p -> next -> prev = s;s -> prev = p; C. s -> prev = s -> next -> prev;s -> next -> prev = s; D. p -> next -> prev = s -> prev;s -> next -> prev = p; 36.【2024 统考真题】已知带头结点的非空单链表L 的头指针为h, 结点结构为: data next 其中next 是指向直接后继结点的指针。现有指针p 和q, 若p 指向L 中非首且非尾的任意一个结点,则执行语句序列“q = p -> next;p -> next = q -> next;q -> next = h -> next;h -> next = q;”的结果 是( ) B. 在q 所指结点后插入p 所指结点D. 将q 所指结点移动到L 的头结点之后 A. 在p 所指结点后插入q 所指结点C. 将p 所指结点移至L 的头结点之后"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 57,
    "chapter": "第3章 栈、队列和数组",
    "question": "栈和队列具有相同的( )",
    "options": [
      {
        "label": "A",
        "text": "抽象数据类型"
      },
      {
        "label": "B",
        "text": "逻辑结构"
      },
      {
        "label": "C",
        "text": "存储结构"
      },
      {
        "label": "D",
        "text": "运算"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 58,
    "chapter": "第3章 栈、队列和数组",
    "question": "栈是一种( )",
    "options": [
      {
        "label": "A",
        "text": "顺序存储的线性结构"
      },
      {
        "label": "B",
        "text": "链式存储的非线性结构"
      },
      {
        "label": "C",
        "text": "限制存取点的线性结构"
      },
      {
        "label": "D",
        "text": "限制存储点的非线性结构"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 59,
    "chapter": "第3章 栈、队列和数组",
    "question": "下列选项中, ( ) 不是栈的基本操作。",
    "options": [
      {
        "label": "A",
        "text": "删除栈顶元素"
      },
      {
        "label": "B",
        "text": "删除栈底元素"
      },
      {
        "label": "C",
        "text": "判断栈是否为空"
      },
      {
        "label": "D",
        "text": "将栈置为空栈"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 60,
    "chapter": "第3章 栈、队列和数组",
    "question": "假定利用数组a[n] 存储一个栈, 初始栈顶指针top ==-1, 则元素x 进栈的操作为( )",
    "options": [
      {
        "label": "A",
        "text": "a --top = x"
      },
      {
        "label": "B",
        "text": "a top-- = x"
      },
      {
        "label": "C",
        "text": "a ++top = x"
      },
      {
        "label": "D",
        "text": "a top++ = x"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 61,
    "chapter": "第3章 栈、队列和数组",
    "question": "假定用数组a 1⋯n 存储一个栈, 初始栈顶指针top = 1, 则元素x 进栈的操作是( )",
    "options": [
      {
        "label": "A",
        "text": "data top-- = x"
      },
      {
        "label": "B",
        "text": "data top++ = x"
      },
      {
        "label": "C",
        "text": "data --top = x"
      },
      {
        "label": "D",
        "text": "data ++top = x"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 62,
    "chapter": "第3章 栈、队列和数组",
    "question": "假定用数组a 1⋯n 存储一个栈, 初始栈顶指针top = n + 1, 则元素x 进栈的操作是( )",
    "options": [
      {
        "label": "A",
        "text": "data --top = x"
      },
      {
        "label": "B",
        "text": "data top++ = x"
      },
      {
        "label": "C",
        "text": "data top-- = x"
      },
      {
        "label": "D",
        "text": "data ++top = x"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 63,
    "chapter": "第3章 栈、队列和数组",
    "question": "设有一个空栈,栈顶指针为1000H,每个元素需要一个存储单元,执行Push、Push、Pop、Push、 Pop、Push、Pop、Push 操作后, 栈顶指针为( ) )",
    "options": [
      {
        "label": "A",
        "text": "1002H"
      },
      {
        "label": "B",
        "text": "1003H"
      },
      {
        "label": "C",
        "text": "1004H"
      },
      {
        "label": "D",
        "text": "1005H"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 64,
    "chapter": "第3章 栈、队列和数组",
    "question": "和顺序栈相比,链栈有一个比较明显的优势,即( )",
    "options": [
      {
        "label": "A",
        "text": "通常不会出现栈满的情况"
      },
      {
        "label": "B",
        "text": "通常不会出现栈空的情况"
      },
      {
        "label": "C",
        "text": "插入操作更容易实现"
      },
      {
        "label": "D",
        "text": "删除操作更容易实现"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 65,
    "chapter": "第3章 栈、队列和数组",
    "question": "设链表不带头结点且所有操作均在表头进行, 则下列最不适合作为链栈的是(",
    "options": [
      {
        "label": "A",
        "text": "只有表头结点指针,没有表尾指针的双向循环链表"
      },
      {
        "label": "B",
        "text": "只有表尾结点指针,没有表头指针的双向循环链表"
      },
      {
        "label": "C",
        "text": "只有表头结点指针,没有表尾指针的单向循环链表"
      },
      {
        "label": "D",
        "text": "只有表尾结点指针,没有表头指针的单向循环链表"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 66,
    "chapter": "第3章 栈、队列和数组",
    "question": "向一个栈顶指针为top 的链栈(不带头结点) 中插入一个x 结点, 则执行( )",
    "options": [
      {
        "label": "A",
        "text": "top -> next = x"
      },
      {
        "label": "B",
        "text": "x -> next = top -> next;top -> next = x"
      },
      {
        "label": "C",
        "text": "x -> next = top;top = x"
      },
      {
        "label": "D",
        "text": "x -> next = top;top = top -> next"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 67,
    "chapter": "第3章 栈、队列和数组",
    "question": "链栈(不带头结点) 执行Pop 操作, 并将出栈的元素存在x 中, 应该执行( )",
    "options": [
      {
        "label": "A",
        "text": "x = top;top = top -> next"
      },
      {
        "label": "B",
        "text": "x = top -> data"
      },
      {
        "label": "C",
        "text": "top = top -> next;x = top -> data"
      },
      {
        "label": "D",
        "text": "x = top -> data;top = top -> next"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 68,
    "chapter": "第3章 栈、队列和数组",
    "question": "经过以下栈的操作后, 变量x 的值为( ) InitStack(st); Push(st, a); Push(st, b); Pop(st, x); GetTop(st, x);",
    "options": [
      {
        "label": "A",
        "text": "a"
      },
      {
        "label": "B",
        "text": "b"
      },
      {
        "label": "C",
        "text": "NULL"
      },
      {
        "label": "D",
        "text": "false"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 69,
    "chapter": "第3章 栈、队列和数组",
    "question": "三个不同元素依次进栈,能得到( ) 种不同的出栈序列。",
    "options": [
      {
        "label": "A",
        "text": "4"
      },
      {
        "label": "B",
        "text": "5"
      },
      {
        "label": "C",
        "text": "6"
      },
      {
        "label": "D",
        "text": "7"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 70,
    "chapter": "第3章 栈、队列和数组",
    "question": "设a,b,c,d,e,f 以所给的次序进栈, 若在进栈操作时, 允许出栈操作, 则下面得不到的序列为( )",
    "options": [
      {
        "label": "A",
        "text": "fedcba"
      },
      {
        "label": "B",
        "text": "bcafed"
      },
      {
        "label": "C",
        "text": "dcefba"
      },
      {
        "label": "D",
        "text": "cabdef 15. 4 个元素依次进栈的次序为a,b,c,d, 则以c,d 开头的出栈序列的个数为( ) A. 1 B. 2 C. 3 D. 4"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 71,
    "chapter": "第3章 栈、队列和数组",
    "question": "用S 表示进栈操作, 用X 表示出栈操作, 若元素的进栈顺序是1234, 为了得到1342 的出栈顺序, 相 应的S 和X 的操作序列为( ) )",
    "options": [
      {
        "label": "A",
        "text": "SXSXSSXX"
      },
      {
        "label": "B",
        "text": "SSSXXSXX"
      },
      {
        "label": "C",
        "text": "SXSSXXSX"
      },
      {
        "label": "D",
        "text": "SXSSXSXX"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 72,
    "chapter": "第3章 栈、队列和数组",
    "question": "若一个栈的输入序列是1,2,3, ⋯,n, 输出序列的第一个元素是n, 则第i 个输出元素是(",
    "options": [
      {
        "label": "A",
        "text": "不确定"
      },
      {
        "label": "B",
        "text": "n - i"
      },
      {
        "label": "C",
        "text": "n - i - 1"
      },
      {
        "label": "D",
        "text": "n - i + 1"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 73,
    "chapter": "第3章 栈、队列和数组",
    "question": "一个栈的输入序列为1,2,3, ⋯,n, 输出序列的第一个元素是i, 则第j 个输出元素是( )",
    "options": [
      {
        "label": "A",
        "text": "i - j - 1"
      },
      {
        "label": "B",
        "text": "i - j"
      },
      {
        "label": "C",
        "text": "j - i + 1"
      },
      {
        "label": "D",
        "text": "不确定"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 74,
    "chapter": "第3章 栈、队列和数组",
    "question": "某栈的输入序列为a,b,c,d, 下面的4 个序列中, 不可能为其输出序列的是( )",
    "options": [
      {
        "label": "A",
        "text": "a,b,c,d"
      },
      {
        "label": "B",
        "text": "c,b,d,a"
      },
      {
        "label": "C",
        "text": "d,c,a,b"
      },
      {
        "label": "D",
        "text": "a,c,b,d"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 75,
    "chapter": "第3章 栈、队列和数组",
    "question": "若一个栈的输入序列是P1,P2, ⋯,Pn, 输出序列是1,2,3, ⋯,n, 若P3 = 1, 则P1 的值( )",
    "options": [
      {
        "label": "A",
        "text": "可能是2"
      },
      {
        "label": "B",
        "text": "一定是2"
      },
      {
        "label": "C",
        "text": "不可能是2"
      },
      {
        "label": "D",
        "text": "不可能是3"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 76,
    "chapter": "第3章 栈、队列和数组",
    "question": "若一个栈的输入序列是P1,P2, ⋯,Pn, 输出序列是1,2,3, ⋯,n, 若P3 = 3, 则P1 的值( )",
    "options": [
      {
        "label": "A",
        "text": "可能是2"
      },
      {
        "label": "B",
        "text": "不可能是1"
      },
      {
        "label": "C",
        "text": "一定是1"
      },
      {
        "label": "D",
        "text": "一定是2"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 77,
    "chapter": "第3章 栈、队列和数组",
    "question": "已知一个栈的入栈序列是1,2,3,4, 其出栈序列为P1,P2,P3,P4, 则P2,P4 不可能是( )",
    "options": [
      {
        "label": "A",
        "text": "2,4"
      },
      {
        "label": "B",
        "text": "2,1"
      },
      {
        "label": "C",
        "text": "4,3"
      },
      {
        "label": "D",
        "text": "3,4"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 78,
    "chapter": "第3章 栈、队列和数组",
    "question": "设栈的初始状态为空, 当字符序列“n1_”作为栈的输入时, 输出长度为3, 且可用做C 语言标识符 的序列有( ) 个。",
    "options": [
      {
        "label": "A",
        "text": "4"
      },
      {
        "label": "B",
        "text": "5"
      },
      {
        "label": "C",
        "text": "3"
      },
      {
        "label": "D",
        "text": "6"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 79,
    "chapter": "第3章 栈、队列和数组",
    "question": "采用共享栈的好处是( )",
    "options": [
      {
        "label": "A",
        "text": "减少存取时间,降低发生上溢的可能"
      },
      {
        "label": "B",
        "text": "节省存储空间,降低发生上溢的可能"
      },
      {
        "label": "C",
        "text": "减少存取时间,降低发生下溢的可能"
      },
      {
        "label": "D",
        "text": "节省存储空间,降低发生下溢的可能"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 80,
    "chapter": "第3章 栈、队列和数组",
    "question": "设有一个顺序共享栈Share 0:n-1 , 其中第一个栈顶指针top1 的初值为-1, 第二个栈顶指针 top2 的初值为n, 则判断共享栈满的条件是( )",
    "options": [
      {
        "label": "A",
        "text": "top2 - top1 == 1"
      },
      {
        "label": "B",
        "text": "top1 - top2 == 1"
      },
      {
        "label": "C",
        "text": "top1 = top2"
      },
      {
        "label": "D",
        "text": "以上都不对 26.【2009 统考真题】设栈S 和队列Q 的初始状态均为空, 元素abcdefg 依次进入栈S。若每个元素出 栈后, 立即进入队列Q, 且7 个元素出队的顺序是bdcfeag, 则栈S 的容量至少是( ) A. 1 B. 2 C. 3 D. 4 27.【2010 统考真题】若元素a,b,c,d,e,f 依次进栈, 允许进栈、退栈操作交替进行, 但不允许连续3 次进行退栈操作, 不可能得到的出栈序列是( ) D. afedcb A. dcebfa B. cbdaef C. bcaefd 28.【2011 统考真题】元素a,b,c,d,e 依次进入初始为空的栈中, 若元素进栈后可停留、可出栈, 直到 所有元素都出栈, 则在所有可能的出栈序列中, 以元素d 开头的序列个数是( ) A. 3 B. 4 C. 5 D. 6 29.【2013 统考真题】一个栈的入栈序列为1,2,3, ⋯,n, 出栈序列是P1,P2,P3, ⋯,Pn。若P2 = 3, 则P3 可能取值的个数是( ) B. n - 2 C. n - 1 D. 无法确定 A. n - 3 30.【2020 统考真题】对空栈S 进行Push 和Pop 操作, 入栈序列为a,b,c,d,e, 经过Push、Push、 Pop、Push、Pop、Push、Push、Pop 操作后得到的出栈序列是( ) D. b,c,e A. b,a,c B. b,a,e C. b,c,a 31.【2022 统考真题】给定有限符号集S, in 和out 均为S 中所有元素的任意排列。对于初始为空的栈 ST,下列叙述中, 正确的是( ) A. 若in 是ST 的入栈序列,则不能判断out 是否为其可能的出栈序列 B. 若out 是ST 的出栈序列,则不能判断in 是否为其可能的入栈序列 C. 若in 是ST 的入栈序列, out 是对应in 的出栈序列,则in 与out 一定不同 D. 若in 是ST 的入栈序列, out 是对应in 的出栈序列,则in 与out 可能互为倒序"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 81,
    "chapter": "第3章 栈、队列和数组",
    "question": "栈和队列的主要区别在于( ) ) B. 它们的存储结构不一样",
    "options": [
      {
        "label": "A",
        "text": "它们的逻辑结构不一样 C. 所包含的元素不一样 D. 插入、删除操作的限定不一样 2. 队列的“先进先出”特性是指( I.最后插入队列中的元素总是最后被删除 II.当同时进行插入、删除操作时,总是插入操作优先 III.每当有删除操作时, 总要先做一次插入操作 IV.每次从队列中删除的总是最早插入的元素 A. I"
      },
      {
        "label": "B",
        "text": "I 和IV"
      },
      {
        "label": "C",
        "text": "II 和III"
      },
      {
        "label": "D",
        "text": "IV"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 82,
    "chapter": "第3章 栈、队列和数组",
    "question": "允许对队列进行的操作有( )",
    "options": [
      {
        "label": "A",
        "text": "对队列中的元素排序"
      },
      {
        "label": "B",
        "text": "取出最近进队的元素"
      },
      {
        "label": "C",
        "text": "在队列元素之间插入元素"
      },
      {
        "label": "D",
        "text": "删除队首元素"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 83,
    "chapter": "第3章 栈、队列和数组",
    "question": "一个队列的入队顺序是1,2,3,4, 则出队的输出顺序是( )",
    "options": [
      {
        "label": "A",
        "text": "4,3,2,1"
      },
      {
        "label": "B",
        "text": "1,2,3,4"
      },
      {
        "label": "C",
        "text": "1,4,3,2"
      },
      {
        "label": "D",
        "text": "3,2,4,1"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 84,
    "chapter": "第3章 栈、队列和数组",
    "question": "循环队列存储在数组A 0⋯n 中, 入队时的操作为( )",
    "options": [
      {
        "label": "A",
        "text": "rear = rear + 1"
      },
      {
        "label": "B",
        "text": "rear = rear+1 mod n-1"
      },
      {
        "label": "C",
        "text": "rear = rear+1 modn"
      },
      {
        "label": "D",
        "text": "rear = rear+1 mod n+1"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 85,
    "chapter": "第3章 栈、队列和数组",
    "question": "已知循环队列的存储空间为数组A[21], front 指向队头元素的前一个位置, rear 指向队尾元素,假设 当前front 和rear 的值分别为8 和3,则该队列的长度为( )",
    "options": [
      {
        "label": "A",
        "text": "5"
      },
      {
        "label": "B",
        "text": "6"
      },
      {
        "label": "C",
        "text": "16"
      },
      {
        "label": "D",
        "text": "17"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 86,
    "chapter": "第3章 栈、队列和数组",
    "question": "若用数组A 0⋯5 来实现循环队列, 且当前rear 和front 的值分别为1 和5, 当从队列中删除一个元 素,再加入两个元素后, rear 和front 的值分别为( )",
    "options": [
      {
        "label": "A",
        "text": "3 和4"
      },
      {
        "label": "B",
        "text": "3 和0"
      },
      {
        "label": "C",
        "text": "5 和0"
      },
      {
        "label": "D",
        "text": "5 和1"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 87,
    "chapter": "第3章 栈、队列和数组",
    "question": "假设用数组Q[Maxsize] 实现循环队列,队首指针front 指向队首元素的前一位置,队尾指针rear 指 向队尾元素, 则判断该队列为空的条件是( ) B. (Q.rear + 1)%MaxSize == Q. front + 1",
    "options": [
      {
        "label": "A",
        "text": "Q.rear == Q.front+1 %MaxSize C. (Q.rear + 1)%Maxsize == Q.front D. Q.rear == Q. front 9. 假设循环队列Q[MaxSize] 的队头指针为front,队尾指针为rear,队列的最大容量为MaxSize,此外,该 队列再没有其他数据成员,则判断该队的列满条件是( ) A. Q. front == Q. rear"
      },
      {
        "label": "B",
        "text": "Q. front + Q. rear >= MaxSize"
      },
      {
        "label": "C",
        "text": "Q.front == Q.rear+1 %MaxSize"
      },
      {
        "label": "D",
        "text": "Q.rear = Q.front+1 %MaxSize"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 88,
    "chapter": "第3章 栈、队列和数组",
    "question": "假设用A 0⋯n 实现循环队列, front、rear 分别指向队首元素的前一个位置和队尾元素。若用 (rear + 1)% n+1 == front 作为队满标志, 则( )",
    "options": [
      {
        "label": "A",
        "text": "可用front == rear 作为队空标志"
      },
      {
        "label": "B",
        "text": "队列中最多可有n + 1 个元素"
      },
      {
        "label": "C",
        "text": "可用front > rear 作为队空标志"
      },
      {
        "label": "D",
        "text": "可用( front + 1)% (n + 1) == rear 作为队空标志"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 89,
    "chapter": "第3章 栈、队列和数组",
    "question": "与顺序队列相比, 链式队列( )",
    "options": [
      {
        "label": "A",
        "text": "优点是队列的长度不受限制"
      },
      {
        "label": "B",
        "text": "优点是进队和出队时间效率更高"
      },
      {
        "label": "C",
        "text": "缺点是不能进行顺序访问"
      },
      {
        "label": "D",
        "text": "缺点是不能根据队首指针和队尾指针计算队列的长度"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 90,
    "chapter": "第3章 栈、队列和数组",
    "question": "[图片] 下列描述的几种链表中, 最适合用作队列的是( )",
    "options": [
      {
        "label": "A",
        "text": "带队首指针和队尾指针的循环单链表"
      },
      {
        "label": "B",
        "text": "带队首指针和队尾指针的非循环单链表"
      },
      {
        "label": "C",
        "text": "只带队首指针的非循环单链表"
      },
      {
        "label": "D",
        "text": "只带队首指针的循环单链表"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 91,
    "chapter": "第3章 栈、队列和数组",
    "question": "[图片] 下列描述的几种链表中,最不适合用作链式队列的是( )",
    "options": [
      {
        "label": "A",
        "text": "只带队首指针的非循环双链表"
      },
      {
        "label": "B",
        "text": "只带队首指针的循环双链表"
      },
      {
        "label": "C",
        "text": "只带队尾指针的循环双链表"
      },
      {
        "label": "D",
        "text": "只带队尾指针的循环单链表"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 92,
    "chapter": "第3章 栈、队列和数组",
    "question": "在用单链表实现队列时,队头设在链表的( ) 位置。",
    "options": [
      {
        "label": "A",
        "text": "链头"
      },
      {
        "label": "B",
        "text": "链尾"
      },
      {
        "label": "C",
        "text": "链中"
      },
      {
        "label": "D",
        "text": "以上都可以"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 93,
    "chapter": "第3章 栈、队列和数组",
    "question": "用链式存储方式的队列进行删除操作时需要( )",
    "options": [
      {
        "label": "A",
        "text": "仅修改头指针"
      },
      {
        "label": "B",
        "text": "仅修改尾指针"
      },
      {
        "label": "C",
        "text": "头尾指针都要修改"
      },
      {
        "label": "D",
        "text": "头尾指针可能都要修改"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 94,
    "chapter": "第3章 栈、队列和数组",
    "question": "在一个链队列中,假设队头指针为front,队尾指针为rear, x 所指向的元素需要入队,则需要执行的操作为( )",
    "options": [
      {
        "label": "A",
        "text": "front = x, front = front -> next"
      },
      {
        "label": "B",
        "text": "x -> next = front -> next, front = x"
      },
      {
        "label": "C",
        "text": "rear -> next = x, rear = x"
      },
      {
        "label": "D",
        "text": "rear -> next = x,x -> next = NULL, rear = x"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 95,
    "chapter": "第3章 栈、队列和数组",
    "question": "假设循环单链表表示的队列长度为n, 队头固定在链表尾, 若只设头指针, 则进队操作的时间复杂 度为( ) )",
    "options": [
      {
        "label": "A",
        "text": "O n"
      },
      {
        "label": "B",
        "text": "O 1"
      },
      {
        "label": "C",
        "text": "O n2"
      },
      {
        "label": "D",
        "text": "O nlog2n"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 96,
    "chapter": "第3章 栈、队列和数组",
    "question": "假设输入序列为1, 2, 3, 4, 5,利用两个队列进行出入队操作,不可能输出的序列是(",
    "options": [
      {
        "label": "A",
        "text": "1,2,3,4,5"
      },
      {
        "label": "B",
        "text": "5,2,3,4,1"
      },
      {
        "label": "C",
        "text": "1,3,2,4,5"
      },
      {
        "label": "D",
        "text": "4,1,5,2,3"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 97,
    "chapter": "第3章 栈、队列和数组",
    "question": "若以1,2,3,4 作为双端队列的输入序列, 则既不能由输入受限的双端队列得到, 又不能由输出受限 的双端队列得到的输出序列是( ) C. 4,2,3,1 D. 4,2,1,3",
    "options": [
      {
        "label": "A",
        "text": "1,2,3,4"
      },
      {
        "label": "B",
        "text": "4,1,3,2 20.【2010 统考真题】某队列允许在其两端进行入队操作, 但仅允许在一端进行出队操作。若元素a, b,c,d,e 依次入此队列后再进行出队操作, 则不可能得到的出队序列是( ) A. b,a,c,d,e B. d,b,a,c,e"
      },
      {
        "label": "C",
        "text": "d,b,c,a,e"
      },
      {
        "label": "D",
        "text": "e,c,b,a,d 21.【2011 统考真题】已知循环队列存储在一维数组A 0⋯n-1 中, 且队列非空时front 和rear 分别 指向队头元素和队尾元素。若初始时队列为空, 且要求第一个进入队列的元素存储在A 0 处, 则初 始时front 和rear 的值分别是( ) A. 0,0 B. 0,n - 1 C. n - 1,0 D. n - 1,n - 1 22.【2014 统考真题】循环队列放在一维数组A 0⋯M-1 中, end1 指向队头元素, end2 指向队尾元 素的后一个位置。假设队列两端均可进行入队和出队操作, 队列中最多能容纳M - 1 个元素。初始 时为空。下列判断队空和队满的条件中,正确的是( ) A. 队空:end1 == end2; 队满:end1 == (end2 + 1)modM B. 队空:end1 == end2; 队满:end2 == (end1 + 1)mod(M - 1) C. 队空:end2 == (end1 + 1)modM; 队满:end1 == (end2 + 1)modM D. 队空:end1 == end2+1 mod M; 队满:end2 == (end1 + 1)mod(M - 1) 23.【2018 统考真题】现有队列Q 与栈S, 初始时Q 中的元素依次是1,2,3,4,5,6 1在队头,S 为空。 若仅允许下列3 种操作: ①出队并输出出队元素；②出队并将出队元素入栈；③出栈并输出出栈元 素, 则不能得到的输出序列是( ) C. 3,4,5,6,1,2 D. 6,5,4,3,2,1 A. 1,2,5,6,4,3 B. 2,3,4,5,6,1 24.【2021 统考真题】初始为空的队列Q 的一端仅能进行入队操作, 另外一端既能进行入队操作又能 进行出队操作。若Q 的入队序列是1,2,3,4,5, 则不能得到的出队序列是( ) A. 5,4,3,1,2 B. 5,3,1,2,4 C. 4,2,1,3,5 D. 4,1,3,2,5"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 98,
    "chapter": "第3章 栈、队列和数组",
    "question": "栈的应用不包括( ) ) C. 括号匹配 D. 缓冲区",
    "options": [
      {
        "label": "A",
        "text": "递归"
      },
      {
        "label": "B",
        "text": "表达式求值 2. 表达式a * b+c - d 的后缀表达式是("
      },
      {
        "label": "C",
        "text": "abc *+d -"
      },
      {
        "label": "D",
        "text": "-+* abcd A. abcd *+ - B. abc +*d -"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 99,
    "chapter": "第3章 栈、队列和数组",
    "question": "下面( ) 用到了队列。 C. 递归 D. FIFO 页面替换算法",
    "options": [
      {
        "label": "A",
        "text": "括号匹配"
      },
      {
        "label": "B",
        "text": "表达式求值    4. 利用栈求表达式的值时,设立运算数栈OPEN。假设OPEN 只有两个存储单元,则在下列表达式中, 不会发生溢出的是( ) * C - D"
      },
      {
        "label": "C",
        "text": " A-B*C - D"
      },
      {
        "label": "D",
        "text": " A-B * C-D A. A - B * C-D B.  A-B"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 100,
    "chapter": "第3章 栈、队列和数组",
    "question": "执行完下列语句段后, i 的值为( )",
    "options": [
      {
        "label": "A",
        "text": "2"
      },
      {
        "label": "B",
        "text": "4"
      },
      {
        "label": "C",
        "text": "8 )"
      },
      {
        "label": "D",
        "text": "无限递归"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 101,
    "chapter": "第3章 栈、队列和数组",
    "question": "设有如下递归函数, 则计算F 8 需要调用该递归函数的次数为(",
    "options": [
      {
        "label": "A",
        "text": "7"
      },
      {
        "label": "B",
        "text": "8"
      },
      {
        "label": "C",
        "text": "9"
      },
      {
        "label": "D",
        "text": "10"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 102,
    "chapter": "第3章 栈、队列和数组",
    "question": "设有如下递归函数,在func( func(5)) 的执行过程中,第4 个被执行的func 函数是( )",
    "options": [
      {
        "label": "A",
        "text": "func(2)"
      },
      {
        "label": "B",
        "text": "func(3)"
      },
      {
        "label": "C",
        "text": "func(4)"
      },
      {
        "label": "D",
        "text": "func(5)"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 103,
    "chapter": "第3章 栈、队列和数组",
    "question": "对于一个问题的递归算法求解和其相对应的非递归算法求解,( )",
    "options": [
      {
        "label": "A",
        "text": "递归算法通常效率高一些"
      },
      {
        "label": "B",
        "text": "非递归算法通常效率高一些"
      },
      {
        "label": "C",
        "text": "两者相同"
      },
      {
        "label": "D",
        "text": "无法比较"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 104,
    "chapter": "第3章 栈、队列和数组",
    "question": "执行函数时,其局部变量一般采用( ) 进行存储。",
    "options": [
      {
        "label": "A",
        "text": "树形结构"
      },
      {
        "label": "B",
        "text": "静态链表"
      },
      {
        "label": "C",
        "text": "栈结构"
      },
      {
        "label": "D",
        "text": "队列结构"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 105,
    "chapter": "第3章 栈、队列和数组",
    "question": "执行( ) 操作时, 需要使用队列作为辅助存储空间。",
    "options": [
      {
        "label": "A",
        "text": "查找散列(哈希) 表"
      },
      {
        "label": "B",
        "text": "广度优先搜索图"
      },
      {
        "label": "C",
        "text": "前序(根) 遍历二叉树"
      },
      {
        "label": "D",
        "text": "深度优先搜索图"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 106,
    "chapter": "第3章 栈、队列和数组",
    "question": "下列说法中, 正确的是( )",
    "options": [
      {
        "label": "A",
        "text": "消除递归不一定需要使用栈"
      },
      {
        "label": "B",
        "text": "对同一输入序列进行两组不同的合法入栈和出栈组合操作,所得的输出序列也一定相同"
      },
      {
        "label": "C",
        "text": "通常使用队列来处理函数或过程调用"
      },
      {
        "label": "D",
        "text": "队列和栈都是运算受限的线性表,只允许在表的两端进行运算 12.【2009 统考真题】为解决计算机主机与打印机之间速度不匹配的问题,通常设置一个打印数据缓冲区,主机将要输出的数据依次写入该缓冲区, 而打印机则依次从该缓冲区中取出数据。该缓冲区的 逻辑结构应该是( ) B. 队列 C. 树 D. 图 A. 栈 13.【2012 统考真题】已知操作符包括“+”“-”“*”“/”“(”和“)”。将中缀表达式a + b - a *   c+d /e- f + g 转换为等价的后缀表达式ab + acd + e/f -*-g + 时, 用栈来存放暂时还不能确定 运算次序的操作符。栈初始时为空时,转换过程中同时保存在栈中的操作符的最大个数是( ) A. 5 B. 7 C. 8 D. 11 14.【2014 统考真题】假设栈初始为空, 将中缀表达式:a/b + c*d-e* f /g 转换为等价的后缀表达式 的过程中, 当扫描到f 时, 栈中的元素依次是( ) A. + (*- B. + (- * C. / + (*- * D. / ++* 15.【2015 统考真题】已知程序如下: 程序运行时使用栈来保存调用过程的信息, 自栈底到栈顶保存的信息依次对应的是( ) A. main →S 1 →S 0 B. S 0 →S 1 →main C. main →S 0 →S 1 D. S 1 →S 0 →main 16.【2016 统考真题】设有如下图所示的火车车轨, 入口到出口之间有n 条轨道, 列车的行进方向均为从左至右, 列车可驶入任意一条轨道。现有编号为1 ∼9 的9 列列车, 驶入的次序依次是8,4,2,5,3, 9,1,6, 7。若期望驶出的次序依次为1 ∼9, 则n 至少是( ) A. 2 B. 3 C. 4 D. 5    17.【2017 统考真题】下列关于栈的叙述中,错误的是( ) I.采用非递归方式重写递归程序时必须使用栈II.函数调用时,系统要用栈保存必要的信息III.只要确定了入栈次序,即可确定出栈次序IV.栈是一种受限的线性表,允许在其两端进行操作 A. 仅I B. 仅I、II、III C. 仅I、III、IV D. 仅II、III、IV 18.【2018 统考真题】若栈S1 中保存整数,栈S2 中保存运算符,函数F( ) 依次执行下述各步操作: 1) 从S1 中依次弹出两个操作数a 和b 2) 从S2 中弹出一个运算符op 3) 执行相应的运算bopa 4) 将运算结果压入S1 中 假定S1 中的操作数依次是5,8,3,2(2 在栈顶), S2 中的运算符依次是*、-、+ (+ 在栈顶)。调用3 次F 后, S1 栈顶保存的值是( ) C. - 20 D. 20 A. - 15 B. 15 19.【2024 统考真题】与表达式x + y * z-u /v 等价的后缀表达式是( ) A. xyzw -* v/ + B. xyzu - v/ *+ C. + x/ * y - zuv D. + x * y/ - zw"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 107,
    "chapter": "第3章 栈、队列和数组",
    "question": "对特殊矩阵采用压缩存储的主要目的是( ) 中,",
    "options": [
      {
        "label": "A",
        "text": "表达变得简单"
      },
      {
        "label": "B",
        "text": "对矩阵元素的存取变得简单"
      },
      {
        "label": "C",
        "text": "去掉矩阵中的多余元素"
      },
      {
        "label": "D",
        "text": "减少不必要的存储空间"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 108,
    "chapter": "第3章 栈、队列和数组",
    "question": "对n 阶对称矩阵压缩存储时, 需要表长为( ) 的顺序表。",
    "options": [
      {
        "label": "A",
        "text": "n/2"
      },
      {
        "label": "B",
        "text": "n × n/2"
      },
      {
        "label": "C",
        "text": "n n+1 /2"
      },
      {
        "label": "D",
        "text": "n n-1 /2"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 109,
    "chapter": "第3章 栈、队列和数组",
    "question": "有一个n × n 的对称矩阵A, 将其下三角部分按行存放在一维数组B 中, 而A 0  0 存放于B 0 则第i + 1 行的对角元素A i  i 存放于B 中的( ) 处。",
    "options": [
      {
        "label": "A",
        "text": " i+3 i/2"
      },
      {
        "label": "B",
        "text": " i+1 i/2"
      },
      {
        "label": "C",
        "text": " 2n-i+1 i/2"
      },
      {
        "label": "D",
        "text": " 2n-i-1 i/2"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 110,
    "chapter": "第3章 栈、队列和数组",
    "question": "在二维数组A 中, 假设每个数组元素的长度为3 个存储单元, 行下标i 为0 ∼8, 列下标j 为0 ∼9, 从 首地址SA 开始连续存放。在这种情况下, 元素A 8  5 的起始地址为( )",
    "options": [
      {
        "label": "A",
        "text": "SA + 141"
      },
      {
        "label": "B",
        "text": "SA + 144"
      },
      {
        "label": "C",
        "text": "SA + 222"
      },
      {
        "label": "D",
        "text": "SA + 255"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 111,
    "chapter": "第3章 栈、队列和数组",
    "question": "二维数组A 按行优先存储, 其中每个元素占1 个存储单元。若A 1  1 的存储地址为420, A 3  3 的存储地址为446,则A[5] [5] 的存储地址为( )",
    "options": [
      {
        "label": "A",
        "text": "472"
      },
      {
        "label": "B",
        "text": "471"
      },
      {
        "label": "C",
        "text": "458"
      },
      {
        "label": "D",
        "text": "457"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 112,
    "chapter": "第3章 栈、队列和数组",
    "question": "将三对角矩阵A 1⋯100  1⋯100 按行优先存入一维数组B 1⋯298 , 数组A 中元素A 66  65 在数组B 中的位置k 为( )",
    "options": [
      {
        "label": "A",
        "text": "198"
      },
      {
        "label": "B",
        "text": "195"
      },
      {
        "label": "C",
        "text": "197"
      },
      {
        "label": "D",
        "text": "196"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 113,
    "chapter": "第3章 栈、队列和数组",
    "question": "若将n 阶上三角矩阵A 按列优先级压缩存放在一维数组B 1⋯n n+1 /2+1 中, 则存放到B k 中 的非零元素ai,j 1≤i,j≤n 的下标i、j 与k 的对应关系是( )",
    "options": [
      {
        "label": "A",
        "text": "i i+1 /2 + j"
      },
      {
        "label": "B",
        "text": "i i-1 /2 + j - 1"
      },
      {
        "label": "C",
        "text": "j j-1 /2 + i"
      },
      {
        "label": "D",
        "text": "j j-1 /2 + i - 1"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 114,
    "chapter": "第3章 栈、队列和数组",
    "question": "若将n 阶下三角矩阵A 按列优先顺序压缩存放在一维数组B 1⋯n n+1 /2+1 中, 则存放到B k 中的非零元素ai,j 1≤i,j≤n 的下标i,j 与k 的对应关系是( )",
    "options": [
      {
        "label": "A",
        "text": " j-1  2n- j+1 /2 + i - j"
      },
      {
        "label": "B",
        "text": " j-1  2n- j+2 /2 + i - j + 1"
      },
      {
        "label": "C",
        "text": " j-1  2n- j+2 /2 + i - j"
      },
      {
        "label": "D",
        "text": " j-1  2n- j+1 /2 + i - j - 1"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 115,
    "chapter": "第3章 栈、队列和数组",
    "question": "稀疏矩阵采用压缩存储后的缺点主要是( )",
    "options": [
      {
        "label": "A",
        "text": "无法判断矩阵的行列数"
      },
      {
        "label": "B",
        "text": "丧失随机存取的特性"
      },
      {
        "label": "C",
        "text": "无法由行、列值查找某个矩阵元素"
      },
      {
        "label": "D",
        "text": "使矩阵元素之间的逻辑关系更复杂"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 116,
    "chapter": "第3章 栈、队列和数组",
    "question": "下列关于矩阵的说法中, 正确的是( ) I.在n n>3 阶三对角矩阵中, 每行都有3 个非零元 II.稀疏矩阵的特点是矩阵中的元素较少",
    "options": [
      {
        "label": "A",
        "text": "仅I"
      },
      {
        "label": "B",
        "text": "仅II"
      },
      {
        "label": "C",
        "text": "I 和II"
      },
      {
        "label": "D",
        "text": "无正确项 11.【2016 统考真题】有一个100 阶的三对角矩阵M, 其元素mi,j 1≤i,j≤100 按行优先依次压缩存 入下标从0 开始的一维数组N 中。元素m30,30 在N 中的下标是( ) A. 86 B. 87 C. 88 D. 89 12.【2017 统考真题】适用于压缩存储稀疏矩阵的两种存储结构是( ) A. 三元组表和十字链表 B. 三元组表和邻接矩阵 C. 十字链表和二叉链表 D. 邻接矩阵和十字链表 13.【2018 统考真题】设有一个12 × 12 的对称矩阵M , 将其上三角部分的元素mi,j 1≤i≤j≤12 按 行优先存入C 语言的一维数组N 中, 元素m6,6 在N 中的下标是( ) A. 50 B. 51 C. 55 D. 66 14.【2020 统考真题】将一个10 × 10 对称矩阵M 的上三角部分的元素mi,j 1≤i≤j≤10 按列优先存 入C 语言的一维数组N 中, 元素m7,2 在N 中的下标是( ) A. 15 B. 16 C. 22 D. 23 15.【2021 统考真题】二维数组A 按行优先方式存储, 每个元素占用1 个存储单元。若元素A 0  0 的存储地址是100, A[3] [3] 的存储地址是220, 则元素A 5  5 的存储地址是( ) A. 295 B. 300 C. 301 D. 306    16.【2023 统考真题】若采用三元组表存储结构存储稀疏矩阵M, 则除三元组表外, 下列数据中还需 要保存的是( ) II. M 中包含非零元素的行数 III. M 的列数 I. M 的行数 IV. M 中包含非零元素的列数 A. 仅I、III B. 仅I、IV C. 仅II、IV D. I、II、III、IV"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 117,
    "chapter": "第3章 栈、队列和数组",
    "question": "设有两个串S1 和S2, 求S2 在S1 中首次出现的位置的运算称为( )",
    "options": [
      {
        "label": "A",
        "text": "求子串"
      },
      {
        "label": "B",
        "text": "判断是否相等"
      },
      {
        "label": "C",
        "text": "模式匹配"
      },
      {
        "label": "D",
        "text": "连接"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 118,
    "chapter": "第3章 栈、队列和数组",
    "question": "KMP 算法的特点是在模式匹配时, 指示主串的指针( )",
    "options": [
      {
        "label": "A",
        "text": "不会变大"
      },
      {
        "label": "B",
        "text": "不会变小"
      },
      {
        "label": "C",
        "text": "都有可能"
      },
      {
        "label": "D",
        "text": "无法判断"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 119,
    "chapter": "第3章 栈、队列和数组",
    "question": "设主串的长度为n, 子串的长度为m, 则简单的模式匹配算法的时间复杂度为( ), KMP 算法的时 间复杂度为( )",
    "options": [
      {
        "label": "A",
        "text": "O m"
      },
      {
        "label": "B",
        "text": "O n"
      },
      {
        "label": "C",
        "text": "O mn"
      },
      {
        "label": "D",
        "text": "O m+n"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 120,
    "chapter": "第3章 栈、队列和数组",
    "question": "在KMP 匹配中, 用next 数组存放模式串的部分匹配信息, 当模式串位j 与主串位i 比较时, 两个字 符不相等, 则j 的位移方式是( ) C. j 不变 D. j = next j",
    "options": [
      {
        "label": "A",
        "text": "j = 0"
      },
      {
        "label": "B",
        "text": "j = j + 1 5. 在KMP 匹配中, 用next 数组存放模式串的部分匹配信息, 当模式串位j 与主串位i 比较时, 两个字 符不相等, 则i 的位移方式是( ) ) )"
      },
      {
        "label": "C",
        "text": "i = 0"
      },
      {
        "label": "D",
        "text": "i = i + 1 A. i = next[i] B. i 不变"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 121,
    "chapter": "第3章 栈、队列和数组",
    "question": "串'ababaaababaa' 的next 数组值为( B. 0,1,2,1,2,1,1,1,1,2,1,2",
    "options": [
      {
        "label": "A",
        "text": "0,1,2,3,4,5,6,7,8,9,9 C. 0,1,1,2,3,4,2,2,3,4,5,6 D. 0,1,2,3,0,1,2,3,2,2,3,4,5 7. 串'ababaaababaa' 的next 数组为("
      },
      {
        "label": "B",
        "text": "- 1,0,1,0,1,0,0,0,0,1,0,1 A. - 1,0,1,2,3,4,5,6,7,8,8,8"
      },
      {
        "label": "C",
        "text": "- 1,0,0,1,2,3,1,1,2,3,4,5"
      },
      {
        "label": "D",
        "text": "- 1,0,1,2, -1,0,1,2,1,1,2,3"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 122,
    "chapter": "第3章 栈、队列和数组",
    "question": "设主串S = ​aabaaaba, 模式串T = ​aaab, 采用KMP 算法进行模式匹配, 到匹配成功时为止, 在匹 配过程中进行的单个字符间的比较次数是( ) C. 8 D. 7",
    "options": [
      {
        "label": "A",
        "text": "10"
      },
      {
        "label": "B",
        "text": "9 9. 设主串S = ​aabaaaba', 模式串T = ​aaab, 采用改进后的KMP 算法进行模式匹配, 到匹配成功时 为止, 在匹配过程中进行的单个字符间的比较次数是( ) D. 6 A. 9 B. 8"
      },
      {
        "label": "C",
        "text": "7 10. KMP 算法使用nextval 数组进行模式匹配, 模式串为S = ​ababaaa, 当主串中的某字符与S 中的 第6 个字符失配时, S 向右滑动的距离是( ) C. 3"
      },
      {
        "label": "D",
        "text": "4 A. 1 B. 2    11.【2015 统考真题】已知字符串s 为'abaabaabacacaabaabcc', 模式串t 为'abaabc', 采用KMP 算法 进行匹配, 第一次出现“失配” (s[i] ≠t[ j]) 时, i = j = 5, 则下次开始匹配时, i 和j 的值分别是( ) A. i = 1,j = 0 B. i = 5,j = 0 C. i = 5,j = 2 D. i = 6,j = 2 12.【2019 统考真题】设主串T = ​abaabaabcabaabc ​, 模式串S = ​abaabc ​, 采用KMP 算法进行模 式匹配, 到匹配成功时为止, 在匹配过程中进行的单个字符间的比较次数是( ) A. 9 B. 10 C. 12 D. 15 13.【2024 统考真题】KMP 算法使用修正后的next 数组进行模式匹配, 模式串为S = ​aabaab, 当主 串的某个字符与S 的某个字符失配时, S 向右滑动的最长距离是( ) D. 2 A. 5 B. 4 C. 3"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 123,
    "chapter": "第5章 树与二叉树",
    "question": "1 树的基本概念1.树最适合用来表示( ) 的数据。",
    "options": [
      {
        "label": "A",
        "text": "有序"
      },
      {
        "label": "B",
        "text": "无序"
      },
      {
        "label": "C",
        "text": "任意元素之间具有多种联系"
      },
      {
        "label": "D",
        "text": "元素之间具有分支层次关系"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 124,
    "chapter": "第5章 树与二叉树",
    "question": "一棵有n 个结点的树的所有结点的度数之和为( )",
    "options": [
      {
        "label": "A",
        "text": "n - 1"
      },
      {
        "label": "B",
        "text": "n"
      },
      {
        "label": "C",
        "text": "n + 1"
      },
      {
        "label": "D",
        "text": "2n"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 125,
    "chapter": "第5章 树与二叉树",
    "question": "树的路径长度是从树根到每个结点的路径长度的( )",
    "options": [
      {
        "label": "A",
        "text": "总和"
      },
      {
        "label": "B",
        "text": "最小值"
      },
      {
        "label": "C",
        "text": "最大值"
      },
      {
        "label": "D",
        "text": "平均值"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 126,
    "chapter": "第5章 树与二叉树",
    "question": "对于一棵具有n 个结点、度为4 的树来说,( )",
    "options": [
      {
        "label": "A",
        "text": "树的高度至多是n - 3"
      },
      {
        "label": "B",
        "text": "树的高度至多是n - 4"
      },
      {
        "label": "C",
        "text": "第i 层上至多有4 i-1 个结点"
      },
      {
        "label": "D",
        "text": "至少在某一层上正好有4 个结点"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 127,
    "chapter": "第5章 树与二叉树",
    "question": "度为4、高度为h 的树,( )",
    "options": [
      {
        "label": "A",
        "text": "至少有h + 3 个结点"
      },
      {
        "label": "B",
        "text": "至多有4h - 1 个结点"
      },
      {
        "label": "C",
        "text": "至多有4h 个结点"
      },
      {
        "label": "D",
        "text": "至少有h + 4 个结点"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 128,
    "chapter": "第5章 树与二叉树",
    "question": "假定一棵度为3 的树中,结点数为50,则其最小高度为( )",
    "options": [
      {
        "label": "A",
        "text": "3"
      },
      {
        "label": "B",
        "text": "4"
      },
      {
        "label": "C",
        "text": "5"
      },
      {
        "label": "D",
        "text": "6"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 129,
    "chapter": "第5章 树与二叉树",
    "question": "设有一棵度为3 的树, 其中度为3 的结点数n3 = 2, 度为2 的结点数n2 = 1, 叶结点数n0 = 6, 则该树 的结点总数为( ) B. 9 C. 10 D. ≥9 的任意整数",
    "options": [
      {
        "label": "A",
        "text": "12 8. 设一棵m 叉树中有N1 个度数为1 的结点, N2 个度数为2 的结点, ⋯,Nm 个度数为m 的结点, 则该树 中共有( ) 个叶结点。"
      },
      {
        "label": "B",
        "text": "m Ni"
      },
      {
        "label": "C",
        "text": "m  i-1 Ni"
      },
      {
        "label": "D",
        "text": "m  i-1 Ni + 1 m A. i=1  i-1 Ni i=1 i=2 i=2 9.【2010 统考真题】在一棵度为4 的树T 中,若有20 个度为4 的结点, 10 个度为3 的结点, 1 个度为2 的结点, 10 个度为1 的结点,则树T 的叶结点个数是( ) ) A. 41 B. 82 C. 113 D. 122 10.【2016 统考真题】若森林F 有15 条边、25 个结点, 则F 包含树的个数是( A. 8 B. 9 C. 10 D. 11"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 130,
    "chapter": "第5章 树与二叉树",
    "question": "下列关于二叉树的说法中,正确的是( )",
    "options": [
      {
        "label": "A",
        "text": "度为2 的有序树就是二叉树"
      },
      {
        "label": "B",
        "text": "含有n 个结点的二叉树的高度为log2n + 1"
      },
      {
        "label": "C",
        "text": "在完全二叉树中,若一个结点没有左孩子,则它必是叶结点"
      },
      {
        "label": "D",
        "text": "含有n 个结点的完全二叉树的高度为log2n"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 131,
    "chapter": "第5章 树与二叉树",
    "question": "“二叉树为空”意味着二叉树( ) B. 不存在D. 由一些没有赋值的空结点构成 )",
    "options": [
      {
        "label": "A",
        "text": "根结点没有子树C. 没有结点 3. 下列关于完全二叉树的说法中, 正确的是( A. 在完全二叉树中,叶结点的双亲的左兄弟(若存在) 一定不是叶结点"
      },
      {
        "label": "B",
        "text": "任何一棵二叉树, 叶结点个数为度为2 的结点数减1, 即n0 = n2 - 1"
      },
      {
        "label": "C",
        "text": "完全二叉树不适合顺序存储结构, 只有满二叉树适合顺序存储结构"
      },
      {
        "label": "D",
        "text": "结点按完全二叉树层序编号的二叉树中, 第i 个结点的左孩子的编号为2i"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 132,
    "chapter": "第5章 树与二叉树",
    "question": "具有10 个叶结点的二叉树中有( ) 个度为2 的结点。 )",
    "options": [
      {
        "label": "A",
        "text": "8"
      },
      {
        "label": "B",
        "text": "9"
      },
      {
        "label": "C",
        "text": "10"
      },
      {
        "label": "D",
        "text": "11"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 133,
    "chapter": "第5章 树与二叉树",
    "question": "设高度为h 的二叉树.上只有度为0 和度为2 的结点, 则此类二叉树中所包含的结点数至少为(",
    "options": [
      {
        "label": "A",
        "text": "h"
      },
      {
        "label": "B",
        "text": "2h - 1"
      },
      {
        "label": "C",
        "text": "2h + 1"
      },
      {
        "label": "D",
        "text": "h + 1"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 134,
    "chapter": "第5章 树与二叉树",
    "question": "具有n 个结点且高度为n 的二叉树的数目为( )",
    "options": [
      {
        "label": "A",
        "text": "log2n"
      },
      {
        "label": "B",
        "text": "n/2"
      },
      {
        "label": "C",
        "text": "n"
      },
      {
        "label": "D",
        "text": "2n-1"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 135,
    "chapter": "第5章 树与二叉树",
    "question": "假设一棵二叉树的结点个数为50,则它的最小高度是( )",
    "options": [
      {
        "label": "A",
        "text": "4"
      },
      {
        "label": "B",
        "text": "5"
      },
      {
        "label": "C",
        "text": "6"
      },
      {
        "label": "D",
        "text": "7"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 136,
    "chapter": "第5章 树与二叉树",
    "question": "设二又树有2n 个结点, 且m < n, 则不可能存在( ) 的结点。",
    "options": [
      {
        "label": "A",
        "text": "n 个度为0"
      },
      {
        "label": "B",
        "text": "2m 个度为0"
      },
      {
        "label": "C",
        "text": "2m 个度为1"
      },
      {
        "label": "D",
        "text": "2m 个度为2"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 137,
    "chapter": "第5章 树与二叉树",
    "question": "一个具有1025 个结点的二叉树的高h 为( )",
    "options": [
      {
        "label": "A",
        "text": "11"
      },
      {
        "label": "B",
        "text": "10"
      },
      {
        "label": "C",
        "text": "11 ∼1025"
      },
      {
        "label": "D",
        "text": "10 ∼1024"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 138,
    "chapter": "第5章 树与二叉树",
    "question": "设二叉树只有度为0 和2 的结点,其结点个数为15,则该二叉树的最大深度为( )",
    "options": [
      {
        "label": "A",
        "text": "4"
      },
      {
        "label": "B",
        "text": "5"
      },
      {
        "label": "C",
        "text": "8"
      },
      {
        "label": "D",
        "text": "9"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 139,
    "chapter": "第5章 树与二叉树",
    "question": "高度为h 的完全二叉树最少有( ) 个结点。",
    "options": [
      {
        "label": "A",
        "text": "2h"
      },
      {
        "label": "B",
        "text": "2h+ 1"
      },
      {
        "label": "C",
        "text": "2h-1"
      },
      {
        "label": "D",
        "text": "2h- 1"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 140,
    "chapter": "第5章 树与二叉树",
    "question": "已知一棵完全二叉树的第6 层(设根为第1 层) 有8 个叶结点,则完全二叉树的结点个数最少是 ( )",
    "options": [
      {
        "label": "A",
        "text": "39"
      },
      {
        "label": "B",
        "text": "52"
      },
      {
        "label": "C",
        "text": "111"
      },
      {
        "label": "D",
        "text": "119"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 141,
    "chapter": "第5章 树与二叉树",
    "question": "若一棵深度为6 的完全二叉树的第6 层有3 个叶结点,则该二叉树共有( ) 个叶结点。",
    "options": [
      {
        "label": "A",
        "text": "17"
      },
      {
        "label": "B",
        "text": "18"
      },
      {
        "label": "C",
        "text": "19"
      },
      {
        "label": "D",
        "text": "20"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 142,
    "chapter": "第5章 树与二叉树",
    "question": "一棵完全二叉树上有1001 个结点,其中叶结点的个数是( )",
    "options": [
      {
        "label": "A",
        "text": "250"
      },
      {
        "label": "B",
        "text": "500"
      },
      {
        "label": "C",
        "text": "254"
      },
      {
        "label": "D",
        "text": "501"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 143,
    "chapter": "第5章 树与二叉树",
    "question": "若一棵二叉树有126 个结点,在第7 层(根结点在第1 层) 至多有( ) 个结点。",
    "options": [
      {
        "label": "A",
        "text": "32"
      },
      {
        "label": "B",
        "text": "64"
      },
      {
        "label": "C",
        "text": "63"
      },
      {
        "label": "D",
        "text": "不存在第7 层"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 144,
    "chapter": "第5章 树与二叉树",
    "question": "一棵有124 个叶结点的完全二叉树,最多有( ) 个结点。",
    "options": [
      {
        "label": "A",
        "text": "247"
      },
      {
        "label": "B",
        "text": "248"
      },
      {
        "label": "C",
        "text": "249"
      },
      {
        "label": "D",
        "text": "250"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 145,
    "chapter": "第5章 树与二叉树",
    "question": "某完全二叉树T 中,结点个数最大的层有8 个结点,则T 中至多有( ) 个结点。",
    "options": [
      {
        "label": "A",
        "text": "8"
      },
      {
        "label": "B",
        "text": "15"
      },
      {
        "label": "C",
        "text": "23"
      },
      {
        "label": "D",
        "text": "31"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 146,
    "chapter": "第5章 树与二叉树",
    "question": "一棵有n 个结点的二叉树采用二叉链存储结点, 其中空指针数为( )",
    "options": [
      {
        "label": "A",
        "text": "n"
      },
      {
        "label": "B",
        "text": "n + 1"
      },
      {
        "label": "C",
        "text": "n - 1"
      },
      {
        "label": "D",
        "text": "2n"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 147,
    "chapter": "第5章 树与二叉树",
    "question": "设有n n≥1 个结点的二叉树采用三叉链表表示, 其中每个结点包含三个指针, 分别指向其左孩 子、右孩子及双亲(若不存在, 则置为空), 则下列说法中正确的是( ) I.树中空指针的数量为n + 2 II.所有度为2 的结点均被三个指针指向 III.每个叶结点均被一个指针所指向",
    "options": [
      {
        "label": "A",
        "text": "I"
      },
      {
        "label": "B",
        "text": "I、II"
      },
      {
        "label": "C",
        "text": "I、III"
      },
      {
        "label": "D",
        "text": "II、III"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 148,
    "chapter": "第5章 树与二叉树",
    "question": "在一棵完全二叉树中, 其根的序号为1,( ) 可判定序号为p 和q 的两个结点是否在同一层。B. log2p = log2q",
    "options": [
      {
        "label": "A",
        "text": " log2p = log2q C.  log2p + 1 = log2q D.  log2p = log2q + 1 21. 在一个用数组表示的完全二叉树中,根结点的下标为1,那么下标为17 和19 的结点的最近公共祖 先的下标是( ) D. 8 D. 6 ) D. 3n A. 1"
      },
      {
        "label": "B",
        "text": "2"
      },
      {
        "label": "C",
        "text": "4 22. 假定一棵三叉树的结点数为50,则它的最小高度为( ) A. 3 B. 4 C. 5 23. 具有n 个结点的三叉树用三叉链表表示, 则树中空指针域的个数为( A. 3n + 1 B. 2n + 1 C. 3n - 1    24. 对于一棵满二叉树, 共有n 个结点和m 个叶结点, 高度为h, 则( )"
      },
      {
        "label": "D",
        "text": "n = 2h- 1 A. n = h + m B. n + m = 2h C. m = h - 1 25.【2009 统考真题】已知一棵完全二叉树的第6 层(设根为第1 层) 有8 个叶结点,则该完全二叉树 的结点个数最多是( ) ) A. 39 B. 52 C. 111 D. 119 26.【2011 统考真题】若一棵完全二叉树有768 个结点,则该二叉树中叶结点的个数是( A. 257 B. 258 C. 384 D. 385 27.【2018 统考真题】设一棵非空完全二叉树T 的所有叶结点均位于同一层, 且每个非叶结; 点都有2个子结点。若T 有k 个叶结点, 则T 的结点总数是( ) A. 2k - 1 B. 2k C. k2 D. 2k- 1 28.【2020 统考真题】对于任意一棵高度为5 且有10 个结点的二叉树,若采用顺序存储结构保存,每个 结点占1 个存储单元(仅存放结点的数据信息),则存放该二叉树需要的存储单元数量至少是( ) A. 31 B. 16 C. 15 D. 10 29.【2022 统考真题】若三叉树T 中有244 个结点(叶结点的高度为1),则T 的高度至少是( ) A. 8 B. 7 C. 6 D. 5"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 149,
    "chapter": "第5章 树与二叉树",
    "question": "在下列关于二叉树遍历的说法中, 正确的是( )",
    "options": [
      {
        "label": "A",
        "text": "若有一个结点是二叉树中某个子树的中序遍历结果序列的最后一个结点,则它一定是该子树的前 序遍历结果序列的最后一个结点"
      },
      {
        "label": "B",
        "text": "若有一个结点是二叉树中某个子树的前序遍历结果序列的最后一个结点,则它一定是该子树的中 序遍历结果序列的最后一个结点"
      },
      {
        "label": "C",
        "text": "若有一个叶结点是二叉树中某个子树的中序遍历结果序列的最后一个结点,则它一定是该子树的 前序遍历结果序列的最后一个结点"
      },
      {
        "label": "D",
        "text": "若有一个叶结点是二叉树中某个子树的前序遍历结果序列的最后一个结点,则它一定是该子树的 中序遍历结果序列的最后一个结点"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 150,
    "chapter": "第5章 树与二叉树",
    "question": "在任何一棵二叉树中, 若结点a 有左孩子b、右孩子c, 则在结点的先序序列、中序序列、后序序 列中, ( )",
    "options": [
      {
        "label": "A",
        "text": "结点b 一定在结点a 的前面"
      },
      {
        "label": "B",
        "text": "结点a 一定在结点c 的前面"
      },
      {
        "label": "C",
        "text": "结点b 一定在结点c 的前面"
      },
      {
        "label": "D",
        "text": "结点a 一定在结点b 的前面"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 151,
    "chapter": "第5章 树与二叉树",
    "question": "设n,m 为一棵二叉树, 上的两个结点, 在中序遍历时, n 在m 前的条件是( )",
    "options": [
      {
        "label": "A",
        "text": "n 在m 右方"
      },
      {
        "label": "B",
        "text": "n 是m 祖先"
      },
      {
        "label": "C",
        "text": "n 在m 左方"
      },
      {
        "label": "D",
        "text": "n 是m 子孙"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 152,
    "chapter": "第5章 树与二叉树",
    "question": "设n, m 为一棵二叉树上的两个结点, 在后序遍历时, n 在m 前的充分条件是( )",
    "options": [
      {
        "label": "A",
        "text": "n 在m 右方"
      },
      {
        "label": "B",
        "text": "n 是m 祖先"
      },
      {
        "label": "C",
        "text": "n 在m 左方"
      },
      {
        "label": "D",
        "text": "n 是m 子孙"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 153,
    "chapter": "第5章 树与二叉树",
    "question": "某非空二叉树采用顺序存储结构,树中的结点信息按完全二叉树的层次序列依次存放在如下所示 的一维数组中,则该二叉树的后序遍历序列为( ) 0 1 2 3 4 5 6 7 8 9 10 11 12 a b c d e f g h",
    "options": [
      {
        "label": "A",
        "text": "ghbefhca"
      },
      {
        "label": "B",
        "text": "gbdehcfa"
      },
      {
        "label": "C",
        "text": "gdbhefca"
      },
      {
        "label": "D",
        "text": "bgdehcfa"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 154,
    "chapter": "第5章 树与二叉树",
    "question": "在二叉树的前序序列、中序序列和后序序列中,所有叶结点的先后顺序( )",
    "options": [
      {
        "label": "A",
        "text": "都不相同"
      },
      {
        "label": "B",
        "text": "完全相同"
      },
      {
        "label": "C",
        "text": "前序和中序相同,而与后序不同"
      },
      {
        "label": "D",
        "text": "中序和后序相同,而与前序不同"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 155,
    "chapter": "第5章 树与二叉树",
    "question": "对二叉树的结点从1 开始进行连续编号,要求每个结点的编号大于其左、右孩子的编号,同一结点 的左、右孩子中, 其左孩子的编号小于其右孩子的编号, 可采用( ) 次序的遍历实现编号。",
    "options": [
      {
        "label": "A",
        "text": "先序遍历"
      },
      {
        "label": "B",
        "text": "中序遍历"
      },
      {
        "label": "C",
        "text": "后序遍历"
      },
      {
        "label": "D",
        "text": "层次遍历"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 156,
    "chapter": "第5章 树与二叉树",
    "question": "按某种顺序对二叉树的结点进行编号, 编号为1,2, ⋯,n, 规定: 树中任一结点v, 其编号等于v 的左 子树上的最小编号减1, 而v 的右子树中的最小编号等于v 的左子树上的最大编号加1, 则说明该二 叉树是按( ) 次序编号的。",
    "options": [
      {
        "label": "A",
        "text": "中序遍历"
      },
      {
        "label": "B",
        "text": "先序遍历"
      },
      {
        "label": "C",
        "text": "后序遍历"
      },
      {
        "label": "D",
        "text": "层次遍历"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 157,
    "chapter": "第5章 树与二叉树",
    "question": "前序序列为A, B, C, 后序序列为C, B, A 的二叉树共有( )",
    "options": [
      {
        "label": "A",
        "text": "1 棵"
      },
      {
        "label": "B",
        "text": "2 棵"
      },
      {
        "label": "C",
        "text": "3 棵"
      },
      {
        "label": "D",
        "text": "4 棵"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 158,
    "chapter": "第5章 树与二叉树",
    "question": "一棵完全二叉树的后序遍历序列为CDBFGEA,则其先序遍历序列是( )",
    "options": [
      {
        "label": "A",
        "text": "CBDAFEG"
      },
      {
        "label": "B",
        "text": "ABECDFG"
      },
      {
        "label": "C",
        "text": "ABCDEFG"
      },
      {
        "label": "D",
        "text": "无法确定"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 159,
    "chapter": "第5章 树与二叉树",
    "question": "设结点X 和Y 是二叉树中任意的两个结点。在该二叉树的先序遍历序列中X 在Y 之前, 而在其后 序遍历序列中X 在Y 之后, 则X 和Y 的关系是( ) ) D. X 是Y 的后裔",
    "options": [
      {
        "label": "A",
        "text": "X 是Y 的左兄弟"
      },
      {
        "label": "B",
        "text": "X 是Y 的右兄弟"
      },
      {
        "label": "C",
        "text": "X 是Y 的祖先 12. 若二叉树中结点的先序序列... a... b...,中序序列是... b... a...,则( A. 结点a 和结点b 分别在某结点的左子树和右子树中 B. 结点b 在结点a 的右子树中 C. 结点b 在结点a 的左子树中"
      },
      {
        "label": "D",
        "text": "结点a 和结点b 分别在某结点的两棵非空子树中"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 160,
    "chapter": "第5章 树与二叉树",
    "question": "一棵二叉树的前序遍历序列为1234567,它的中序遍历序列可能是( ) D. 1463572",
    "options": [
      {
        "label": "A",
        "text": "3124567"
      },
      {
        "label": "B",
        "text": "1234567"
      },
      {
        "label": "C",
        "text": "4135627    14. 下列序列中,不能唯一地确定一棵二叉树的是( ) A. 层次序列和中序序列 B. 先序序列和中序序列 C. 后序序列和中序序列"
      },
      {
        "label": "D",
        "text": "先序序列和后序序列"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 161,
    "chapter": "第5章 树与二叉树",
    "question": "若一棵二叉树的中序序列和后序序列相同,则( )",
    "options": [
      {
        "label": "A",
        "text": "二叉树为空树或二叉树任一结点没有左子树"
      },
      {
        "label": "B",
        "text": "二叉树为空树或二叉树任一结点没有右子树"
      },
      {
        "label": "C",
        "text": "二叉树为空树或二叉树中每个结点的度为1"
      },
      {
        "label": "D",
        "text": "二叉树为空树或二叉树为满二叉树"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 162,
    "chapter": "第5章 树与二叉树",
    "question": "已知一棵二叉树的后序序列为DABEC,中序序列为DEBAC,则先序序列为( ) ) (假",
    "options": [
      {
        "label": "A",
        "text": "ACBED"
      },
      {
        "label": "B",
        "text": "DECAB"
      },
      {
        "label": "C",
        "text": "DEABC"
      },
      {
        "label": "D",
        "text": "CEDBA"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 163,
    "chapter": "第5章 树与二叉树",
    "question": "已知一棵二叉树的先序遍历结果为ABCDEF,中序遍历结果为CBAEDF,则后序遍历的结果为(",
    "options": [
      {
        "label": "A",
        "text": "CBEFDA"
      },
      {
        "label": "B",
        "text": "FEDCBA"
      },
      {
        "label": "C",
        "text": "CBEDFA"
      },
      {
        "label": "D",
        "text": "不确定"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 164,
    "chapter": "第5章 树与二叉树",
    "question": "已知一棵二叉树的层次序列为ABCDEF,中序序列为BADCFE,则先序序列为( )",
    "options": [
      {
        "label": "A",
        "text": "ACBEDF"
      },
      {
        "label": "B",
        "text": "ABCDEF"
      },
      {
        "label": "C",
        "text": "BDFECA"
      },
      {
        "label": "D",
        "text": "FCEDBA"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 165,
    "chapter": "第5章 树与二叉树",
    "question": "某二叉树中的结点x 在先序、中序、后序遍历序列中的编号分别为pre x 、in x 、post x 设都是从1 开始依次顺序编号), a 和b 是二叉树中的任意两个结点, 其中a 是b 的祖先, 下列选项中 不可能出现的是( ) B. post(a) > post(b) C. in(a) < in(b) D. in(a) > in(b)",
    "options": [
      {
        "label": "A",
        "text": "pre(a) < pre(b) 20. 某二叉树采用二叉链表存储结构,若要删除该二叉链表中的所有结点,并释放它们占用的存储空 间,则采用( ) 遍历方法最合适。 C. 后序 D. 先序 A. 中序"
      },
      {
        "label": "B",
        "text": "层次 21. 某二叉树T 采用二叉链表存储结构, T 的中序遍历序列为一个升序序列,要求采用某种方法对T 进行某种操作之后得到一棵新的二叉树T, 要求T的中序遍历序列为一个降序序列, 则下列关于该算 法的叙述中,正确的是( ) B. 采用后序遍历的方法最合适D. T中的叶结点不一定是原T 中的叶结点 B. 为了能在二叉树中方便插入和删除 D. 使二叉树的遍历结果唯一 A. 采用中序遍历的方法最合适"
      },
      {
        "label": "C",
        "text": "T中的根结点还是原T 中的根结点 22. 引入线索二叉树的目的是( ) A. 加快查找结点的前驱或后继的速度C. 为了能方便找到双亲 23. 线索二叉树是一种( ) 结构。 C. 物理"
      },
      {
        "label": "D",
        "text": "线性 A. 逻辑 B. 逻辑和存储"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 166,
    "chapter": "第5章 树与二叉树",
    "question": "n 个结点的线索二叉树上含有的线索数为( )",
    "options": [
      {
        "label": "A",
        "text": "2n"
      },
      {
        "label": "B",
        "text": "n - 1"
      },
      {
        "label": "C",
        "text": "n + 1"
      },
      {
        "label": "D",
        "text": "n"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 167,
    "chapter": "第5章 树与二叉树",
    "question": "判断线索二叉树中* p 结点有右孩子结点的条件是( )",
    "options": [
      {
        "label": "A",
        "text": "p! = NULL"
      },
      {
        "label": "B",
        "text": "p -> rchild! = NULL"
      },
      {
        "label": "C",
        "text": "p -> rtag == 0"
      },
      {
        "label": "D",
        "text": "p -> rtag == 1"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 168,
    "chapter": "第5章 树与二叉树",
    "question": "一棵左子树为空的二叉树在先序线索化后,其中空的链域的个数是( )",
    "options": [
      {
        "label": "A",
        "text": "不确定"
      },
      {
        "label": "B",
        "text": "0 个"
      },
      {
        "label": "C",
        "text": "1 个"
      },
      {
        "label": "D",
        "text": "2 个"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 169,
    "chapter": "第5章 树与二叉树",
    "question": "在线索二叉树中,下列说法不正确的是( )",
    "options": [
      {
        "label": "A",
        "text": "在中序线索树中,若某结点有右孩子,则其后继结点是它的右子树的最左下结点"
      },
      {
        "label": "B",
        "text": "在中序线索树中,若某结点有左孩子,则其前驱结点是它的左子树的最右下结点"
      },
      {
        "label": "C",
        "text": "线索二叉树是利用二叉树的n + 1 个空指针来存放结点的前驱和后继信息的"
      },
      {
        "label": "D",
        "text": "每个结点通过线索都可以直接找到它的前驱和后继"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 170,
    "chapter": "第5章 树与二叉树",
    "question": "二叉树在线索化后, 仍不能有效求解的问题是( )",
    "options": [
      {
        "label": "A",
        "text": "先序线索二叉树中求先序后继"
      },
      {
        "label": "B",
        "text": "中序线索二叉树中求中序后继"
      },
      {
        "label": "C",
        "text": "中序线索二叉树中求中序前驱"
      },
      {
        "label": "D",
        "text": "后序线索二叉树中求后序后继"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 171,
    "chapter": "第5章 树与二叉树",
    "question": "若X 是二叉中序线索树中一个有左孩子的结点, 且X 不为根, 则X 的前驱为( )",
    "options": [
      {
        "label": "A",
        "text": "X 的双亲"
      },
      {
        "label": "B",
        "text": "X 的右子树中最左的结点"
      },
      {
        "label": "C",
        "text": "X 的左子树中最右的结点"
      },
      {
        "label": "D",
        "text": "X 的左子树中最右的叶结点"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 172,
    "chapter": "第5章 树与二叉树",
    "question": "若X 是后序线索二叉树中的叶结点, 且X 存在左兄弟Y, 则X 的右线索指向的是( )",
    "options": [
      {
        "label": "A",
        "text": "X 的双亲"
      },
      {
        "label": "B",
        "text": "以Y 为根的子树的最左下结点"
      },
      {
        "label": "C",
        "text": "X 的左兄弟Y"
      },
      {
        "label": "D",
        "text": "以Y 为根的子树的最右下结点"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 173,
    "chapter": "第5章 树与二叉树",
    "question": "( ) 的遍历仍需要栈的支持。",
    "options": [
      {
        "label": "A",
        "text": "前序线索树"
      },
      {
        "label": "B",
        "text": "中序线索树"
      },
      {
        "label": "C",
        "text": "后序线索树"
      },
      {
        "label": "D",
        "text": "所有线索树"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 174,
    "chapter": "第5章 树与二叉树",
    "question": "某二叉树的先序序列和后序序列正好相反, 则该二叉树一定是( )",
    "options": [
      {
        "label": "A",
        "text": "空或只有一个结点"
      },
      {
        "label": "B",
        "text": "高度等于其结点数"
      },
      {
        "label": "C",
        "text": "任意一个结点无左孩子"
      },
      {
        "label": "D",
        "text": "任意一个结点无右孩子"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 175,
    "chapter": "第5章 树与二叉树",
    "question": "某非空二叉树的先序序列和中序序列正好相反, 则下列叙述中正确的是( )",
    "options": [
      {
        "label": "A",
        "text": "该二叉树一定只有一个结点"
      },
      {
        "label": "B",
        "text": "只有一个叶结点的二叉树一定满足条件"
      },
      {
        "label": "C",
        "text": "任意一个结点无左孩子的二叉树一定满足条件"
      },
      {
        "label": "D",
        "text": "任意一个结点无右孩子的二叉树一定满足条件    34.【2009 统考真题】给定二叉树如下图所示。设N 代表二叉树的根, L 代表根结点的左子树, R 代表 A. LRN C. RLN B. NRL D. RNL 根结点的右子树。若遍历后的结点序列是3175624, 则其遍历方式是( ) 35.【2010 统考真题】下列线索二叉树中(用虚线表示线索), 符合后序线索树定义的是( ) 36.【2011 统考真题】一棵二叉树的前序遍历序列和后序遍历序列分别为1,2,3,4 和4,3,2,1, 该二叉 树的中序遍历序列不会是( ) C. 3,2,4,1 D. 4,3,2,1 A. 1,2,3,4 B. 2,3,4,1 37.【2012 统考真题】若一棵二叉树的前序遍历序列为a, e, b, d, c,后序遍历序列为b, c, d, e, a,则根结 点的孩子结点( ) B. 有e、b C. 有e、c D. 无法确定 A. 只有e 38.【2013 统考真题】若X 是后序线索二叉树中的叶结点, 且X 存在左兄弟结点Y, 则X 的右线索指 向的是( ) A. X 的父结点 B. 以Y 为根的子树的最左下结点 C. X 的左兄弟结点Y D. 以Y 为根的子树的最右下结点 39.【2014】若对下图所示的二叉树进行中序线索化, 则结点x 的左、右线索指向的结点分别是( ) A. e,c B. e, a ) C. d,c D. b,a 40.【2015 统考真题】先序序列为a, b, c, d 的不同二叉树的个数是( A. 13 B. 14 C. 15 D. 16 41.【2017 统考真题】某二叉树的树形如下图所示,其后序序列为e, a, c, b, d, g, f ,树中与结点a 同层的 结点是( ) B. d A. c C. f D. g    42.【2017 统考真题】要使一棵非空二叉树的先序序列与中序序列相同,其所有非叶结点须满足的条 件是( ) B. 只有右子树 C. 结点的度均为1 D. 结点的度均为2 A. 只有左子树 43.【2022 统考真题】若结点p 与q 在二叉树T 的中序遍历序列中相邻, 且p 在q 之前, 则下列p 与q 的关系中, 不可能的是( ) II. q 是p 的右孩子 III. q 是p 的右兄弟 I. q 是p 的双亲 IV. q 是p 的双亲的双亲 A. 仅I B. 仅III C. 仅II、III D. 仅II、IV 44.【2023 统考真题】已知一棵二叉树的树形如下图所示,若其后序遍历序列为f , d, b, e, c, a,则其先 序遍历序列是( ) B. a, c, e, b, d, f A. a, e, d, f , b, c C. c, a, b, e, f , d D. d, f , e, b, a, c 45.【2024 统考真题】若p、q 和v 均为二叉树T 中的结点, v 有两个孩子结点, T 的中序遍历序列形如 “..., p, v, q,... \",则在下列叙述中,正确的是( ) B. p 没有右孩子, q 有左孩子 A. p 没有右孩子, q 没有左孩子 C. p 有右孩子, q 没有左孩子 D. p 有右孩子, q 有左孩子"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 176,
    "chapter": "第5章 树与二叉树",
    "question": "下列关于树的说法中, 正确的是( ) I.对于有n 个结点的二叉树, 其高度为log2n II.完全二叉树中,若一个结点没有左孩子,则它必是叶结点 III.高度为h h>0 的完全二叉树对应的森林所含的树的个数一定是h IV.一棵树中的叶子数一定等于与其对应的二叉树的叶子数",
    "options": [
      {
        "label": "A",
        "text": "I 和III"
      },
      {
        "label": "B",
        "text": "IV"
      },
      {
        "label": "C",
        "text": "I 和II"
      },
      {
        "label": "D",
        "text": "II D. 不一定为空"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 177,
    "chapter": "第5章 树与二叉树",
    "question": "利用二叉链表存储森林时, 根结点的右指针是( )",
    "options": [
      {
        "label": "A",
        "text": "指向最左兄弟"
      },
      {
        "label": "B",
        "text": "指向最右兄弟"
      },
      {
        "label": "C",
        "text": "一定为空 3. 设森林F 中有3 棵树, 第1、第2、第3 棵树的结点个数分别为M1,M2 和M3。与森林F 对应的二 叉树根结点的右子树上的结点个数是( ) C. M3"
      },
      {
        "label": "D",
        "text": "M2 + M3 A. M1 B. M1 + M2"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 178,
    "chapter": "第5章 树与二叉树",
    "question": "设森林F 中有4 棵树, 第1、2、3、4 棵树的结点数分别为a,b,c 和d, 与森林F 对应的二叉树的根 结点的左子树上的结点数是( ) C. a - 1 D. a + b + c",
    "options": [
      {
        "label": "A",
        "text": "a"
      },
      {
        "label": "B",
        "text": "b + c + d    5. 设森林F 对应的二叉树为B, 它有m 个结点, B 的根为p,p 的右子树结点数为n, 森林F 中第一棵树 的结点数是( ) B. m - n - 1"
      },
      {
        "label": "C",
        "text": "n + 1"
      },
      {
        "label": "D",
        "text": "条件不足,无法确定 A. m - n"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 179,
    "chapter": "第5章 树与二叉树",
    "question": "设森林F 对应的二叉树是一棵具有16 个结点的完全二叉树, 则森林F 中树的数目和结点最多的树 的结点数分别是( )",
    "options": [
      {
        "label": "A",
        "text": "2 和8"
      },
      {
        "label": "B",
        "text": "2 和9"
      },
      {
        "label": "C",
        "text": "4 和8"
      },
      {
        "label": "D",
        "text": "4 和9"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 180,
    "chapter": "第5章 树与二叉树",
    "question": "森林T = T1,T2,⋯,Tm 转化为二叉树BT 的过程为: 若m = 0, 则BT 为空, 若m ≠0, 则( )",
    "options": [
      {
        "label": "A",
        "text": "将中间子树Tmid, mid= 1+m /2 的根作为BT 的根; 将T1,T2,⋯,Tmid-1 转换为BT 的左子树; 将Tmid+1,⋯,Tm 转换为BT 的右子树"
      },
      {
        "label": "B",
        "text": "将子树T1 的根作为BT 的根; 将T1 的子树森林转换成BT 的左子树; 将T2,T3,⋯,Tm 转换成BT 的 右子树"
      },
      {
        "label": "C",
        "text": "将子树T1 的根作为BT 的根; 将T1 的左子树森林转换成BT 的左子树; 将T1 的右子树森林转换为 BT 的右子树; 其他以此类推"
      },
      {
        "label": "D",
        "text": "将森林T 的根作为BT 的根; 将T1,T2,⋯,Tm 转化为该根下的结点, 得到一棵树, 然后将这棵树再 转化为二叉树BT"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 181,
    "chapter": "第5章 树与二叉树",
    "question": "设F 是一个森林, B 是由F 变换来的二叉树。若F 中有n 个非终端结点, 则B 中右指针域为空的结 点有( ) 个。 B. n C. n + 1 D. n + 2",
    "options": [
      {
        "label": "A",
        "text": "n - 1 9. 设某树的孩子兄弟链表示中共有6 个空的左指针域、7 个空的右指针域,包括5 个结点的左、右指 针域都为空, 则该树中叶结点的个数是( ) ) 棵 A. 7"
      },
      {
        "label": "B",
        "text": "6"
      },
      {
        "label": "C",
        "text": "5"
      },
      {
        "label": "D",
        "text": "不能确定"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 182,
    "chapter": "第5章 树与二叉树",
    "question": "若T1 是由有序树T 转换而来的二叉树, 则T 中结点的后根序列就是T1 中结点的( ) 序列。",
    "options": [
      {
        "label": "A",
        "text": "先序"
      },
      {
        "label": "B",
        "text": "中序"
      },
      {
        "label": "C",
        "text": "后序"
      },
      {
        "label": "D",
        "text": "层序"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 183,
    "chapter": "第5章 树与二叉树",
    "question": "某二叉树结点的中序序列为BDAECF,后序序列为DBEFCA,则该二叉树对应的森林包括( 树。",
    "options": [
      {
        "label": "A",
        "text": "1"
      },
      {
        "label": "B",
        "text": "2"
      },
      {
        "label": "C",
        "text": "3"
      },
      {
        "label": "D",
        "text": "4"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 184,
    "chapter": "第5章 树与二叉树",
    "question": "设X 是树T 中的一个非根结点, B 是T 所对应的二叉树。在B 中, X 是其双亲结点的右孩子, 下列 结论中正确的是( ) B. 在树T 中, X 一定无右边兄弟D. 在树T 中, X 一定有左边兄弟",
    "options": [
      {
        "label": "A",
        "text": "在树T 中, X 是其双亲结点的第一个孩子C. 在树T 中, X 一定是叶结点    13. 下图是一棵逻辑上的树T,则在关于该树的存储结构的叙述中,错误的是( ) A. 若T 采用双亲表示法, 则有9 个指向双亲的指针"
      },
      {
        "label": "B",
        "text": "若T 采用孩子表示法, 则在T 中查找某个结点的孩子比双亲表示法更方便"
      },
      {
        "label": "C",
        "text": "若T 采用孩子兄弟表示法, 则在T 中查找某个结点的双亲的时间复杂度为O 1"
      },
      {
        "label": "D",
        "text": "双亲表示法是顺序存储结构, 孩子表示法和孩子兄弟表示法是链式存储结构"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 185,
    "chapter": "第5章 树与二叉树",
    "question": "在森林的二叉树表示中, 结点M 和结点N 是同一父结点的左儿子和右儿子, 则在该森林中( )",
    "options": [
      {
        "label": "A",
        "text": "M 和N 有同一双亲"
      },
      {
        "label": "B",
        "text": "M 和N 可能无公共祖先"
      },
      {
        "label": "C",
        "text": "M 是N 的儿子"
      },
      {
        "label": "D",
        "text": "M 是N 的左兄弟 15.【2009 统考真题】将森林转换为对应的二叉树, 若在二叉树中, 结点u 是结点v 的父结点的父结点, 则在原来的森林中, u 和v 可能具有的关系是( ) I.父子关系 II.兄弟关系 III. u 的父结点与v 的父结点是兄弟关系A. 只有II B. I 和II C. I 和III D. I、II 和III 16.【2011 统考真题】已知一棵有2011 个结点的树,其叶结点个数为116,该树对应的二叉树中无右孩 子的结点个数是( ) A. 115 B. 116 C. 1895 D. 1896 17.【2014 统考真题】将森林F 转换为对应的二叉树T,F 中叶结点的个数等于( ) A. T 中叶结点的个数 B. T 中度为1 的结点个数 C. T 中左孩子指针为空的结点个数 D. T 中右孩子指针为空的结点个数 18.【2019 统考真题】若将一棵树T 转化为对应的二叉树BT, 则下列对BT 的遍历中, 其遍历序列与 T 的后根遍历序列相同的是( ) C. 后序遍历 D. 按层遍历 A. 先序遍历 B. 中序遍历 19.【2020 统考真题】已知森林F 及与之对应的二叉树T,若F 的先根遍历序列是a, b, c, d, e, f ,中根遍 历序列是b, a, d, f , e, c,则T 的后根遍历序列是( ) D. f , e, d, c, b, a A. b, a, d, f , e, c B. b, d, f , e, c, a C. b, f , e, d, c, a 20.【2021 统考真题】某森林F 对应的二叉树为T, 若T 的先序遍历序列是a,b,d,c,e,g,f , 中序遍历序 列是b,d,a,e,g,c,f , 则F 中树的棵数是( ) C. 3 D. 4 A. 1 B. 2"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 186,
    "chapter": "第5章 树与二叉树",
    "question": "在有n 个叶结点的哈夫曼树中, 非叶结点的总数是( ) D. 2n",
    "options": [
      {
        "label": "A",
        "text": "n - 1"
      },
      {
        "label": "B",
        "text": "n"
      },
      {
        "label": "C",
        "text": "2n - 1    2. 给定整数集合{3,5,6,9,12}, 与之对应的哈夫曼树是( ) A. B. C."
      },
      {
        "label": "D",
        "text": "3. 下列编码中,( ) 不是前缀码。 A. {00,01,10,11} B. {0,1,00,11} C. {0,10,110,111} D. {10,110,1110,1111}"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 187,
    "chapter": "第5章 树与二叉树",
    "question": "设哈夫曼编码的长度不超过4,若已对两个字符编码为1 和01,则还最多可对( ) 个字符编码。",
    "options": [
      {
        "label": "A",
        "text": "2"
      },
      {
        "label": "B",
        "text": "3"
      },
      {
        "label": "C",
        "text": "4"
      },
      {
        "label": "D",
        "text": "5"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 188,
    "chapter": "第5章 树与二叉树",
    "question": "一棵哈夫曼树共有215 个结点,对其进行哈夫曼编码,共能得到( ) 个不同的码字。",
    "options": [
      {
        "label": "A",
        "text": "107"
      },
      {
        "label": "B",
        "text": "108"
      },
      {
        "label": "C",
        "text": "214"
      },
      {
        "label": "D",
        "text": "215"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 189,
    "chapter": "第5章 树与二叉树",
    "question": "设某哈夫曼树有5 个叶结点,则该哈夫曼树的高度最高可以是( )",
    "options": [
      {
        "label": "A",
        "text": "3"
      },
      {
        "label": "B",
        "text": "4"
      },
      {
        "label": "C",
        "text": "5"
      },
      {
        "label": "D",
        "text": "6"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 190,
    "chapter": "第5章 树与二叉树",
    "question": "以下对于哈夫曼树的说法中, 错误的是( )",
    "options": [
      {
        "label": "A",
        "text": "用一组权值构造出来的哈夫曼树可能不唯一,但带权路径长度唯一"
      },
      {
        "label": "B",
        "text": "哈夫曼树具有最小的带权路径长度"
      },
      {
        "label": "C",
        "text": "哈夫曼树中没有度为1 的结点"
      },
      {
        "label": "D",
        "text": "哈夫曼树中除了度为1 的结点外,还有度为2 的结点和叶结点"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 191,
    "chapter": "第5章 树与二叉树",
    "question": "下列关于哈夫曼树的说法中, 错误的是( ) I.哈夫曼树的总结点数不能是偶数II.哈夫曼树中度为1 的结点数等于度为2 和0 的结点数之差III.哈夫曼树的带权路径长度等于其所有分支结点的权值之和",
    "options": [
      {
        "label": "A",
        "text": "仅III"
      },
      {
        "label": "B",
        "text": "I 和II"
      },
      {
        "label": "C",
        "text": "仅II"
      },
      {
        "label": "D",
        "text": "I、II 和III"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 192,
    "chapter": "第5章 树与二叉树",
    "question": "若度为m 的哈夫曼树中, 叶结点个数为n, 则非叶结点的个数为( )",
    "options": [
      {
        "label": "A",
        "text": "n - 1"
      },
      {
        "label": "B",
        "text": "⌊n/m ⌋-1"
      },
      {
        "label": "C",
        "text": "  n-1 / m-1"
      },
      {
        "label": "D",
        "text": "⌈n/ m-1 ⌉-1"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 193,
    "chapter": "第5章 树与二叉树",
    "question": "并查集的结构是一种( )",
    "options": [
      {
        "label": "A",
        "text": "二叉链表存储的二叉树"
      },
      {
        "label": "B",
        "text": "双亲表示法存储的树"
      },
      {
        "label": "C",
        "text": "顺序存储的二叉树"
      },
      {
        "label": "D",
        "text": "孩子表示法存储的树"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 194,
    "chapter": "第5章 树与二叉树",
    "question": "并查集中最核心的两个操作是: ①查找,查找两个元素是否属于同一个集合; ②合并,如果两个元素不属于同一个集合, 且所在的两个集合互不相交, 则合并这两个集合。 假设初始长度为10 0∼9 的并查集,按1 - 2、3 - 4、5 - 6、7 - 8、8 - 9、1 - 8、0 - 5、1 - 9 的顺序进行查找和合并操作, 最终并查集共有( ) 个集合。",
    "options": [
      {
        "label": "A",
        "text": "1"
      },
      {
        "label": "B",
        "text": "2"
      },
      {
        "label": "C",
        "text": "3"
      },
      {
        "label": "D",
        "text": "4"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 195,
    "chapter": "第5章 树与二叉树",
    "question": "下列关于并查集的说法中, 正确的是( ) (注: 本题涉及图的考点)",
    "options": [
      {
        "label": "A",
        "text": "并查集不能检测图中是否存在环路的问题"
      },
      {
        "label": "B",
        "text": "通过路径优化后的并查集在最坏情况下的高度仍是O n"
      },
      {
        "label": "C",
        "text": "Find 操作返回集合中元素个数的相反数,它用来作为某个集合的标志"
      },
      {
        "label": "D",
        "text": "Union 操作时可根据当前集合的规模, 将小集合合并到大集合中"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 196,
    "chapter": "第5章 树与二叉树",
    "question": "下列关于并查集的叙述中,( ) 是错误的(注意, 本题涉及图的考点)",
    "options": [
      {
        "label": "A",
        "text": "并查集是用双亲表示法存储的树"
      },
      {
        "label": "B",
        "text": "并查集可用于实现克鲁斯卡尔算法"
      },
      {
        "label": "C",
        "text": "并查集可用于判断无向图的连通性"
      },
      {
        "label": "D",
        "text": "在长度为n 的并查集中进行查找操作的时间复杂度为O log2n 14.【2010 统考真题】n n≥2 个权值均不相同的字符构成哈夫曼树, 关于该树的叙述中, 错误的是 ( ) A. 该树一定是一棵完全二叉树 B. 树中一定没有度为1 的结点 C. 树中两个权值最小的结点一定是兄弟结点 D. 树中任意一个非叶结点的权值一定不小于下一层任意一个结点的权值 15.【2014 统考真题】5 个字符有如下4 种编码方案,不是前缀编码的是( ) A. 01, 0000, 0001, 001, 1 B. 011, 000, 001, 010, 1 C. 000,001,010,011,100 D. 0,100,110,1110,1100 16.【2015 统考真题】下列选项给出的是从根分别到达两个叶结点路径上的权值序列,能属于同一棵 哈夫曼树的是( ) A. 24,10,5 和24,10,7 B. 24,10,5 和24,12,7 C. 24,10,10 和24,14,11 D. 24,10,5 和24,14,6 17.【2017 统考真题】已知字符集{a,b,c,d,e,f ,g,h}, 若各字符的哈夫曼编码依次是0100,10,0000, 0101, 001,011,11,0001, 则编码序列0100011001001011110101 的译码结果是( ) A. acgabfh B. adbagbb C. afbeagd D. afeefgd    18.【2018 统考真题】已知字符集{a,b,c,d,e,f }, 若各字符出现的次数分别为6,3,8,2,10,4, 则对应字 符集中各字符的哈夫曼编码可能是( ) B. 00, 100, 110, 000, 0010, 01 A. 00,1011,01,1010,11,100 C. 10, 1011, 11, 0011, 00, 010 D. 0011, 10, 11, 0010, 01, 000 19.【2019 统考真题】对n 个互不相同的符号进行哈夫曼编码。若生成的哈夫曼树共有115 个结点, 则n 的值是( ) B. 57 C. 58 D. 60 A. 56 20.【2021 统考真题】若某二叉树有5 个叶结点,其权值分别为10, 12, 16, 21, 30,则其最小的带权路径 长度(WPL) 是( ) A. 89 B. 200 C. 208 D. 289 21.【2022 统考真题】对任意给定的含n n>2 个字符的有限集S, 用二叉树表示S 的哈夫曼编码集 和定长编码集, 分别得到二叉树T1 和T2。下列叙述中, 正确的是( ) A. T1 与T2 的结点数相同 B. T1 的高度大于T2 的高度 C. 出现频次不同的字符在T1 中处于不同的层 D. 出现频次不同的字符在T2 中处于相同的层 22.【2023 统考真题】在由6 个字符组成的字符集S 中, 各字符出现的频次分别为3,4,5,6,8,10, 为S 构造的哈夫曼编码的加权平均长度为( ) C."
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 197,
    "chapter": "第5章 树与二叉树",
    "question": "[图片] 图中有关路径的定义是( )",
    "options": [
      {
        "label": "A",
        "text": "由顶点和相邻顶点序偶构成的边所形成的序列"
      },
      {
        "label": "B",
        "text": "由不同顶点所形成的序列"
      },
      {
        "label": "C",
        "text": "由不同边所形成的序列"
      },
      {
        "label": "D",
        "text": "上述定义都不是"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 198,
    "chapter": "第5章 树与二叉树",
    "question": "一个有n 个顶点和n 条边的无向图一定是( ) )",
    "options": [
      {
        "label": "A",
        "text": "连通的"
      },
      {
        "label": "B",
        "text": "不连通的"
      },
      {
        "label": "C",
        "text": "无环的"
      },
      {
        "label": "D",
        "text": "有环的"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 199,
    "chapter": "第5章 树与二叉树",
    "question": "若从无向图的任意顶点出发进行一次深度优先搜索即可访问所有顶点,则该图一定是(",
    "options": [
      {
        "label": "A",
        "text": "强连通图"
      },
      {
        "label": "B",
        "text": "连通图"
      },
      {
        "label": "C",
        "text": "有回路"
      },
      {
        "label": "D",
        "text": "一棵树"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 200,
    "chapter": "第5章 树与二叉树",
    "question": "以下关于图的叙述中,正确的是( )",
    "options": [
      {
        "label": "A",
        "text": "图与树的区别在于图的边数大于等于顶点数"
      },
      {
        "label": "B",
        "text": "假设有图G = {V,{E}}, 顶点集V⊆V,E⊆E, 则V和E 构成G 的子图"
      },
      {
        "label": "C",
        "text": "无向图的连通分量是指无向图中的极大连通子图"
      },
      {
        "label": "D",
        "text": "图的遍历就是从图中某一顶点出发访遍图中其余顶点"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 201,
    "chapter": "第5章 树与二叉树",
    "question": "以下关于图的叙述中,正确的是( )",
    "options": [
      {
        "label": "A",
        "text": "强连通有向图的任何顶点到其他所有顶点都有弧"
      },
      {
        "label": "B",
        "text": "图的任意顶点的入度等于出度"
      },
      {
        "label": "C",
        "text": "有向完全图一定是强连通有向图"
      },
      {
        "label": "D",
        "text": "有向图的边集的子集和顶点集的子集可构成原有向图的子图"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 202,
    "chapter": "第5章 树与二叉树",
    "question": "一个有28 条边的非连通无向图至少有( ) 个顶点。 D. 10 ); 若是强连通有向图, 其边的个 D. n,n n-1",
    "options": [
      {
        "label": "A",
        "text": "7"
      },
      {
        "label": "B",
        "text": "8"
      },
      {
        "label": "C",
        "text": "9 7. 对于一个有n 个顶点的图: 若是连通无向图, 其边的个数至少为( 数至少为( ) A. n - 1,n B. n - 1,n n-1 C. n,n 8. 无向图G 有23 条边, 度为4 的顶点有5 个, 度为3 的顶点有4 个, 其余都是度为2 的顶点, 则图G 有( ) 个顶点。"
      },
      {
        "label": "D",
        "text": "16 D. 2n - 2 A. 11 B. 12 C. 15"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 203,
    "chapter": "第5章 树与二叉树",
    "question": "[图片] 在有n 个顶点的有向图中, 顶点的度最大可达( )",
    "options": [
      {
        "label": "A",
        "text": "n"
      },
      {
        "label": "B",
        "text": "n - 1"
      },
      {
        "label": "C",
        "text": "2n    10. 具有6 个顶点的无向图, 当有( ) 条边时能确保是一个连通图。 A. 8 B. 9 C. 10"
      },
      {
        "label": "D",
        "text": "11"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 204,
    "chapter": "第5章 树与二叉树",
    "question": "设有无向图G = V,E 和G= V,E , 若G是G 的生成树, 则下列不正确的是( ) I. G为G 的连通分量 II. G为G 的无环子图 III. G为G 的极小连通子图且V= V",
    "options": [
      {
        "label": "A",
        "text": "I、II"
      },
      {
        "label": "B",
        "text": "只有III"
      },
      {
        "label": "C",
        "text": "II、III"
      },
      {
        "label": "D",
        "text": "只有I"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 205,
    "chapter": "第5章 树与二叉树",
    "question": "具有51 个顶点和21 条边的无向图的连通分量最多为( )",
    "options": [
      {
        "label": "A",
        "text": "33"
      },
      {
        "label": "B",
        "text": "34"
      },
      {
        "label": "C",
        "text": "45"
      },
      {
        "label": "D",
        "text": "32"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 206,
    "chapter": "第5章 树与二叉树",
    "question": "[图片] 在如下图所示的有向图中, 共有( ) 个强连通分量。",
    "options": [
      {
        "label": "A",
        "text": "1"
      },
      {
        "label": "B",
        "text": "2"
      },
      {
        "label": "C",
        "text": "3"
      },
      {
        "label": "D",
        "text": "4"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 207,
    "chapter": "第5章 树与二叉树",
    "question": "若具有n 个顶点的图是一个环, 则它有( ) 棵生成树。",
    "options": [
      {
        "label": "A",
        "text": "n2"
      },
      {
        "label": "B",
        "text": "n"
      },
      {
        "label": "C",
        "text": "n - 1"
      },
      {
        "label": "D",
        "text": "1"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 208,
    "chapter": "第5章 树与二叉树",
    "question": "若一个具有n 个顶点、e 条边的无向图是一个森林, 则该森林中必有( ) 棵树。",
    "options": [
      {
        "label": "A",
        "text": "n"
      },
      {
        "label": "B",
        "text": "e"
      },
      {
        "label": "C",
        "text": "n - e"
      },
      {
        "label": "D",
        "text": "1 16.【2009 统考真题】下列关于无向连通图特性的叙述中,正确的是( ) I.所有顶点的度之和为偶数 II.边数大于顶点个数减1 III.至少有一个顶点的度为1 A. 只有I B. 只有II C. I 和II D. I 和III 17.【2010 统考真题】若无向图G = V,E 中含有7 个顶点, 要保证图G 在任何情况下都是连通的, 则需要的边数最少是( ) A. 6 B. 15 C. 16 D. 21 18.【2017 统考真题】已知无向图G 含有16 条边,其中度为4 的顶点个数为3,度为3 的顶点个数为4, 其他顶点的度均小于3。图G 所含的顶点个数至少是( ) A. 10 B. 11 C. 13 D. 15 19.【2022 统考真题】对于无向图G = V,E , 下列选项中, 正确的是( ) A. 当V > E 时, G 一定是连通的 B. 当V < E 时, G 一定是连通的 C. 当V = E - 1 时, G 一定是不连通的 D. 当V > E + 1 时, G 一定是不连通的"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 209,
    "chapter": "第5章 树与二叉树",
    "question": "关于图的存储结构,错误的是( )",
    "options": [
      {
        "label": "A",
        "text": "使用邻接矩阵存储一个图时,在不考虑压缩存储的情况下,所占用的存储空间大小只与图中的顶 点数有关,与边数无关"
      },
      {
        "label": "B",
        "text": "邻接表只用于有向图的存储,邻接矩阵适用于有向图和无向图"
      },
      {
        "label": "C",
        "text": "若一个有向图的邻接矩阵的对角线以下的元素为0,则该图的拓扑序列必定存在"
      },
      {
        "label": "D",
        "text": "存储无向图的邻接矩阵是对称的,故只需存储邻接矩阵的下(或上) 三角部分"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 210,
    "chapter": "第5章 树与二叉树",
    "question": "若图的邻接矩阵中主对角线上的元素皆为0, 其余元素全为1, 则可以断定该图一定( )",
    "options": [
      {
        "label": "A",
        "text": "是无向图"
      },
      {
        "label": "B",
        "text": "是有向图"
      },
      {
        "label": "C",
        "text": "是完全图"
      },
      {
        "label": "D",
        "text": "不是带权图"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 211,
    "chapter": "第5章 树与二叉树",
    "question": "在含有n 个顶点和e 条边的无向图的邻接矩阵中, 零元素的个数为( )",
    "options": [
      {
        "label": "A",
        "text": "e"
      },
      {
        "label": "B",
        "text": "2e"
      },
      {
        "label": "C",
        "text": "n2- e"
      },
      {
        "label": "D",
        "text": "n2- 2e"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 212,
    "chapter": "第5章 树与二叉树",
    "question": "带权有向图G 用邻接矩阵存储, 则vi 的入度等于邻接矩阵中( )",
    "options": [
      {
        "label": "A",
        "text": "第i 行非∞的元素个数"
      },
      {
        "label": "B",
        "text": "第i 列非∞的元素个数"
      },
      {
        "label": "C",
        "text": "第i 行非∞且非0 的元素个数"
      },
      {
        "label": "D",
        "text": "第i 列非∞且非0 的元素个数"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 213,
    "chapter": "第5章 树与二叉树",
    "question": "一个有n 个顶点的图用邻接矩阵A 表示, 若图为有向图, 顶点vi 的入度是( ); 若图为无向图, 顶 点vi 的度是( ) n n",
    "options": [
      {
        "label": "A",
        "text": "i=1 A  i  j"
      },
      {
        "label": "B",
        "text": "j=1 A  j  i n n n"
      },
      {
        "label": "C",
        "text": "i=1 A  j  i"
      },
      {
        "label": "D",
        "text": "j=1 A  j  i 或 j=1 A  i  j"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 214,
    "chapter": "第5章 树与二叉树",
    "question": "从邻接矩阵A =    0 1 0 可以看出, 该图共有(①) 个顶点; 若是有向图, 则该图共有(②) 条弧; 若 1 0 1 0 1 0 是无向图, 则共有(③) 条边。 ①",
    "options": [
      {
        "label": "A",
        "text": "9"
      },
      {
        "label": "B",
        "text": "3"
      },
      {
        "label": "C",
        "text": "6"
      },
      {
        "label": "D",
        "text": "1 E.以上答案均不正确 ②A. 5 B. 4 C. 3 D. 2 E.以上答案均不正确 ③A. 5 B. 4 C. 3 D. 2 E.以上答案均不正确"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 215,
    "chapter": "第5章 树与二叉树",
    "question": "以下关于图的存储结构的叙述中,正确的是( )",
    "options": [
      {
        "label": "A",
        "text": "一个图的邻接矩阵表示唯一,邻接表表示唯一"
      },
      {
        "label": "B",
        "text": "一个图的邻接矩阵表示唯一,邻接表表示不唯一"
      },
      {
        "label": "C",
        "text": "一个图的邻接矩阵表示不唯一,邻接表表示唯一"
      },
      {
        "label": "D",
        "text": "一个图的邻接矩阵表示不唯一,邻接表表示不唯一"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 216,
    "chapter": "第5章 树与二叉树",
    "question": "矩阵A 是有向图G 的邻接矩阵, 若矩阵A2的某元素a2 i,j= 3, 则说明( )",
    "options": [
      {
        "label": "A",
        "text": "从顶点i 到j 存在3 条长度为2 的路径"
      },
      {
        "label": "B",
        "text": "从顶点i 到j 存在3 条长度不超过2 的路径"
      },
      {
        "label": "C",
        "text": "从顶点i 到j 存在2 条长度为3 的路径"
      },
      {
        "label": "D",
        "text": "从顶点i 到j 存在2 条长度不超过3 的路径"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 217,
    "chapter": "第5章 树与二叉树",
    "question": "用邻接表法存储图所用的空间大小( )",
    "options": [
      {
        "label": "A",
        "text": "与图的顶点数和边数有关"
      },
      {
        "label": "B",
        "text": "只与图的边数有关"
      },
      {
        "label": "C",
        "text": "只与图的顶点数有关"
      },
      {
        "label": "D",
        "text": "与边数的平方有关"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 218,
    "chapter": "第5章 树与二叉树",
    "question": "[图片] 若邻接表中有奇数个边表结点,则( )",
    "options": [
      {
        "label": "A",
        "text": "图中有奇数个结点"
      },
      {
        "label": "B",
        "text": "图中有偶数个结点"
      },
      {
        "label": "C",
        "text": "图为无向图"
      },
      {
        "label": "D",
        "text": "图为有向图"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 219,
    "chapter": "第5章 树与二叉树",
    "question": "[图片] 在有向图的邻接表存储结构中, 顶点v 在边表中出现的次数是( )",
    "options": [
      {
        "label": "A",
        "text": "顶点v 的度"
      },
      {
        "label": "B",
        "text": "顶点v 的出度"
      },
      {
        "label": "C",
        "text": "顶点v 的入度"
      },
      {
        "label": "D",
        "text": "依附于顶点v 的边数"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 220,
    "chapter": "第5章 树与二叉树",
    "question": "n 个顶点的无向图的邻接表最多有( ) 个边表结点。",
    "options": [
      {
        "label": "A",
        "text": "n2"
      },
      {
        "label": "B",
        "text": "n n-1"
      },
      {
        "label": "C",
        "text": "n n+1"
      },
      {
        "label": "D",
        "text": "n n-1 /2"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 221,
    "chapter": "第5章 树与二叉树",
    "question": "[图片] 设某无向图中有n 个顶点和e 条边, 则建立该图的邻接表的时间复杂度是( )",
    "options": [
      {
        "label": "A",
        "text": "O n+e"
      },
      {
        "label": "B",
        "text": "O n2"
      },
      {
        "label": "C",
        "text": "O ne"
      },
      {
        "label": "D",
        "text": "O n3"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 222,
    "chapter": "第5章 树与二叉树",
    "question": "假设有n 个顶点、e 条边的有向图用邻接表表示, 则删除与某个顶点v 相关的所有边的时间复杂 度为( ) C. O n+e D. O ne",
    "options": [
      {
        "label": "A",
        "text": "O n"
      },
      {
        "label": "B",
        "text": "O e 15. 对邻接表的叙述中, ( ) 是正确的。 A. 无向图的邻接表中, 第i 个顶点的度为第i 个链表中结点数的两倍B. 邻接表比邻接矩阵的操作更简便"
      },
      {
        "label": "C",
        "text": "邻接矩阵比邻接表的操作更简便"
      },
      {
        "label": "D",
        "text": "求有向图结点的度,必须遍历整个邻接表"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 223,
    "chapter": "第5章 树与二叉树",
    "question": "邻接多重表是( ) 的存储结构。 C. 无向图和有向图 D. 都不是",
    "options": [
      {
        "label": "A",
        "text": "无向图"
      },
      {
        "label": "B",
        "text": "有向图 17. 十字链表是( ) 的存储结构。"
      },
      {
        "label": "C",
        "text": "无向图和有向图"
      },
      {
        "label": "D",
        "text": "都不是 A. 无向图 B. 有向图    18.【2013 统考真题】设图的邻接矩阵A 如下所示, 各顶点的度依次是( ) A =  0 1 0 1 0 0 1 1 0 1 0 0 1 0 0 0 A. 1,2,1,2 B. 2,2,1,1 C. 3,4,2,3 D. 4,4,2,2 19.【2024 统考真题】若无向图G = V,E 的邻接多重表如下图所示, 则G 中顶点b 与d 的度分别是 ( ) A. 0,2 B. 2,4 C. 2,5 D. 3,4"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 224,
    "chapter": "第5章 树与二叉树",
    "question": "下列关于广度优先算法的说法中, 正确的是( ) I.当各边的权值相等时,广度优先算法可以解决单源最短路径问题II.当各边的权值不等时, 广度优先算法可用来解决单源最短路径问题III.广度优先遍历算法类似于树中的后序遍历算法IV.实现图的广度优先算法时,使用的数据结构是队列",
    "options": [
      {
        "label": "A",
        "text": "I、IV"
      },
      {
        "label": "B",
        "text": "II、III、IV"
      },
      {
        "label": "C",
        "text": "II、IV"
      },
      {
        "label": "D",
        "text": "I、III、IV"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 225,
    "chapter": "第5章 树与二叉树",
    "question": "[图片] 下列关于图的说法中, 错误的是( ) I.对一个无向图进行深度优先遍历时,得到的深度优先遍历序列是唯一的II.若有向图不存在回路,即使不用访问标志位,同一结点也不会被访问两次III.采用深度优先遍历或拓扑排序算法可以判断一个有向图中是否有环(回路) IV.对任何非强连通图必须2 次或以上调用广度优先遍历算法才可访问所有的顶点",
    "options": [
      {
        "label": "A",
        "text": "I、II、III"
      },
      {
        "label": "B",
        "text": "II、III"
      },
      {
        "label": "C",
        "text": "I、II"
      },
      {
        "label": "D",
        "text": "I、II、IV"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 226,
    "chapter": "第5章 树与二叉树",
    "question": "对于一个非连通无向图G,采用深度优先遍历访问所有顶点,在DFSTraverse 函数(见考点讲解DFS 部分) 中调用DFS 的次数正好等于( ) ), 空间复杂",
    "options": [
      {
        "label": "A",
        "text": "顶点数"
      },
      {
        "label": "B",
        "text": "边数"
      },
      {
        "label": "C",
        "text": "连通分量数"
      },
      {
        "label": "D",
        "text": "不确定"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 227,
    "chapter": "第5章 树与二叉树",
    "question": "对一个有n 个顶点、e 条边的图采用邻接表表示时, 进行DFS 遍历的时间复杂度为( 度为( ); 进行BFS 遍历的时间复杂度为( ),空间复杂度为( )",
    "options": [
      {
        "label": "A",
        "text": "O n"
      },
      {
        "label": "B",
        "text": "O e"
      },
      {
        "label": "C",
        "text": "O n+e"
      },
      {
        "label": "D",
        "text": "O 1"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 228,
    "chapter": "第5章 树与二叉树",
    "question": "图的广度优先遍历算法中使用队列作为其辅助数据结构,那么在算法执行过程中,每个顶点的入队 次数最多为( )",
    "options": [
      {
        "label": "A",
        "text": "1"
      },
      {
        "label": "B",
        "text": "2"
      },
      {
        "label": "C",
        "text": "3"
      },
      {
        "label": "D",
        "text": "4"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 229,
    "chapter": "第5章 树与二叉树",
    "question": "对有n 个顶点、e 条边的图采用邻接矩阵表示时, 进行DFS 遍历的时间复杂度为( ), 进行BFS 遍历的时间复杂度为( )",
    "options": [
      {
        "label": "A",
        "text": "O n2"
      },
      {
        "label": "B",
        "text": "O e"
      },
      {
        "label": "C",
        "text": "O n+e"
      },
      {
        "label": "D",
        "text": "O e2"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 230,
    "chapter": "第5章 树与二叉树",
    "question": "无向图G = V,E , 其中V = {a,b,c,d,e,f },E =   a,b , a,e , a,c , b,e , c,f , f ,d , e,d , 对该 图从a 开始进行深度优先遍历,得到的顶点序列正确的是( )",
    "options": [
      {
        "label": "A",
        "text": "a, b, e, c, d, f"
      },
      {
        "label": "B",
        "text": "a, c, f , e, b, d"
      },
      {
        "label": "C",
        "text": "a, e, b, c, f , d"
      },
      {
        "label": "D",
        "text": "a, e, d, f , c, b"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 231,
    "chapter": "第5章 树与二叉树",
    "question": "[图片] 如下图所示, 在下面的5 个序列中, 符合深度优先遍历的序列个数是( ) ①aebfdc ②acfdeb ③aedfcb ④aefdbc ⑤aecfdb D. 2",
    "options": [
      {
        "label": "A",
        "text": "5"
      },
      {
        "label": "B",
        "text": "4"
      },
      {
        "label": "C",
        "text": "3 9. 用邻接表存储的图的深度优先遍历算法类似于树的( ), 而其广度优先遍历算法类似于树的( ) A. 中序遍历 B. 先序遍历 C. 后序遍历"
      },
      {
        "label": "D",
        "text": "按层次遍历"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 232,
    "chapter": "第5章 树与二叉树",
    "question": "[图片] 一个有向图G 的邻接表存储如下图所示, 从顶点1 出发, 对图G 调用深度优先遍历所得顶点序列 是( ); 按广度优先遍历所得顶点序列是( )",
    "options": [
      {
        "label": "A",
        "text": "125436"
      },
      {
        "label": "B",
        "text": "124536"
      },
      {
        "label": "C",
        "text": "124563"
      },
      {
        "label": "D",
        "text": "362514"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 233,
    "chapter": "第5章 树与二叉树",
    "question": "无向图G = (V,E), 其中V = {a,b,c,d,e,f },E =   a,b , a,e , a,c , b,e , c,f , f ,d , e,d 。对 该图进行深度优先遍历,不能得到的序列是( )",
    "options": [
      {
        "label": "A",
        "text": "acfdeb"
      },
      {
        "label": "B",
        "text": "aebdfc"
      },
      {
        "label": "C",
        "text": "aedfcb"
      },
      {
        "label": "D",
        "text": "abecdf"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 234,
    "chapter": "第5章 树与二叉树",
    "question": "[图片] 判断有向图中是否存在回路, 除可以利用拓扑排序外, 还可以利用( ) (注: 本题涉及下节内容)",
    "options": [
      {
        "label": "A",
        "text": "求关键路径的方法"
      },
      {
        "label": "B",
        "text": "求最短路径的Dijkstra 算法"
      },
      {
        "label": "C",
        "text": "深度优先遍历算法"
      },
      {
        "label": "D",
        "text": "广度优先遍历算法"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 235,
    "chapter": "第5章 树与二叉树",
    "question": "设无向图G = V,E 和G= V,E 若G是G 的生成树, 则下列说法中错误的是( )",
    "options": [
      {
        "label": "A",
        "text": "G为G 的子图"
      },
      {
        "label": "B",
        "text": "G为G 的连通分量"
      },
      {
        "label": "C",
        "text": "G为G 的极小连通子图且V = V"
      },
      {
        "label": "D",
        "text": "G是G 的一个无环子图"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 236,
    "chapter": "第5章 树与二叉树",
    "question": "图的广度优先生成树的树高比深度优先生成树的树高( ) D. 大",
    "options": [
      {
        "label": "A",
        "text": "小或相等"
      },
      {
        "label": "B",
        "text": "小"
      },
      {
        "label": "C",
        "text": "大或相等 15.【2012 统考真题】对有n 个顶点、e 条边且使用邻接表存储的有向图进行广度优先遍历, 其算法 的时间复杂度是( ) A. O n B. O e C. O n+e"
      },
      {
        "label": "D",
        "text": "O ne 16.【2013 统考真题】若对如下无向图进行遍历,则下列选项中,不是广度优先遍历序列的是( ) A. h, c, a, b, d, e, g, f B. e, a, f , g, b, h, c, d C. d, b, c, a, h, e, f , g D. a, b, c, d, h, e, f , g 17.【2015 统考真题】设有向图G = V,E , 顶点集V = V0,V1,V2,V3 边集E = <v0,v1> , < v0,v2> , < v0,v3> ,<v1,v3> 若从顶V0 开始对图进行深度优先遍历, 则可能得到的不同遍历序列个数是( ) A. 2 B. 3 C. 4 D. 5 18.【2016 统考真题】下列选项中,不是下图深度优先搜索序列的是( ) A. V1,V5,V4,V3,V2 B. V1,V3,V2,V5,V4 C. V1,V2,V5,V4,V3 D. V1,V2,V3,V4,V5"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 237,
    "chapter": "第5章 树与二叉树",
    "question": "任何一个无向连通图的最小生成树( )",
    "options": [
      {
        "label": "A",
        "text": "有一棵或多棵"
      },
      {
        "label": "B",
        "text": "只有一棵"
      },
      {
        "label": "C",
        "text": "一定有多棵"
      },
      {
        "label": "D",
        "text": "可能不存在"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 238,
    "chapter": "第5章 树与二叉树",
    "question": "用Prim 算法和Kruskal 算法构造图的最小生成树,所得到的最小生成树( )",
    "options": [
      {
        "label": "A",
        "text": "相同"
      },
      {
        "label": "B",
        "text": "不相同"
      },
      {
        "label": "C",
        "text": "可能相同,可能不同"
      },
      {
        "label": "D",
        "text": "无法比较"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 239,
    "chapter": "第5章 树与二叉树",
    "question": "下列关于图的生成树和最小生成树的叙述中,正确的是( )",
    "options": [
      {
        "label": "A",
        "text": "只要无向连通图中没有权值相同的边,则其最小生成树唯一"
      },
      {
        "label": "B",
        "text": "只要无向图中有权值相同的边,则其最小生成树一定不唯一"
      },
      {
        "label": "C",
        "text": "从n 个顶点的连通图中选取n - 1 条权值最小的边, 即可构成最小生成树"
      },
      {
        "label": "D",
        "text": "设连通图G 含有n 个顶点, 则含有n 个顶点、n - 1 条边的子图一定是G 的生成树"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 240,
    "chapter": "第5章 树与二叉树",
    "question": "设有n 个顶点的无向连通图的最小生成树不唯一, 则下列说法中正确的是( )",
    "options": [
      {
        "label": "A",
        "text": "图的边数一定大于n - 1"
      },
      {
        "label": "B",
        "text": "图的权值最小的边一定有多条"
      },
      {
        "label": "C",
        "text": "图的最小生成树的代价不一定相等"
      },
      {
        "label": "D",
        "text": "图的各条边的权值不相等"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 241,
    "chapter": "第5章 树与二叉树",
    "question": "用Prim 算法求一个带权连通图的最小生成树, 在算法执行的某个时刻, 已选取的顶点集合U = {1, 2,3},已选取的边集合TE =   1,2 , 2,3 , 要选取下一条权值最小的边, 应当从( ) 组中选取。",
    "options": [
      {
        "label": "A",
        "text": "  1,4 , 3,4 , 3,5 , 2,5"
      },
      {
        "label": "B",
        "text": "  3,4 , 3,5 , 4,5 , 1,4"
      },
      {
        "label": "C",
        "text": "  1,2 , 2,3 , 3,5"
      },
      {
        "label": "D",
        "text": "  4,5 , 1,3 , 3,5"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 242,
    "chapter": "第5章 树与二叉树",
    "question": "用Kruskal 算法求一个带权连通图的最小生成树, 在算法执行的某个时刻, 已选取的边集合TE = { 1,2 , 2,3 , 3,5 , 要选取下一条权值最小的边, 不可能选取的边是( ) D. (1,4)",
    "options": [
      {
        "label": "A",
        "text": "(3,6)"
      },
      {
        "label": "B",
        "text": "(2,4)"
      },
      {
        "label": "C",
        "text": "(1,3) 7. 下列关于图的最短路径的相关叙述中,正确的是( ) A. 最短路径一定是简单路径B. Dijkstra 算法不适合求有回路的带权图的最短路径C. Dijkstra 算法不适合求任意两个顶点的最短路径"
      },
      {
        "label": "D",
        "text": "Floyd 算法求两个顶点的最短路径时, pathk-1 一定是pathk 的子集"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 243,
    "chapter": "第5章 树与二叉树",
    "question": "下列关于图的最短路径的相关叙述中,正确的是( ) I. Dijkstra 算法求单源最短路径不允许边的权为负II. Dijkstra 算法求每对顶点间的最短路径的时间复杂度是O n2 III. Floyd 算法求每对顶点间的最短路径允许边的权为负,但不允许含有负边的回路",
    "options": [
      {
        "label": "A",
        "text": "I、II 和III"
      },
      {
        "label": "B",
        "text": "仅I"
      },
      {
        "label": "C",
        "text": "I 和III"
      },
      {
        "label": "D",
        "text": "II 和III"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 244,
    "chapter": "第5章 树与二叉树",
    "question": "已知带权连通无向图G = V,E , 其中V = v1,v2,v3,v4,v5,v6,v7 ,E =   v1,v2 10, v1,v3 2, v3,v4 2 ,  v3,v6 11, v2,v5 1, v4,v5 4, v4,v6 6, v5,v7 7, v6,v7 3 (注: 顶点偶对括号外的数据表示边上的权值), 从源点v1 到顶点v7 以的最短路径上经过的顶点序列是( )",
    "options": [
      {
        "label": "A",
        "text": "v1,v2,v5,v7"
      },
      {
        "label": "B",
        "text": "v1,v3,v4,v6,v7"
      },
      {
        "label": "C",
        "text": "v1,v3,v4,v5,v7"
      },
      {
        "label": "D",
        "text": "v1,v2,v5,v4,v6,v7"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 245,
    "chapter": "第5章 树与二叉树",
    "question": "用Dijkstra 算法求一个带权有向图的从顶点0 出发的最短路径,在算法执行的某个时刻,已求得的 最短路径的顶点集合S = {0,2,3,4}, 下一个选取的目标顶点是顶点1, 则可能修改的最短路径是( )",
    "options": [
      {
        "label": "A",
        "text": "从顶点0 到顶点3 的最短路径"
      },
      {
        "label": "B",
        "text": "从顶点0 到顶点2 的最短路径"
      },
      {
        "label": "C",
        "text": "从顶点2 到顶点4 的最短路径"
      },
      {
        "label": "D",
        "text": "从顶点0 到顶点1 的最短路径"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 246,
    "chapter": "第5章 树与二叉树",
    "question": "下面的( ) 方法可以判断出一个有向图是否有环(回路)。 I.深度优先遍历II.拓扑排序III.求最短路径IV.求关键路径",
    "options": [
      {
        "label": "A",
        "text": "I、II、IV"
      },
      {
        "label": "B",
        "text": "I、III、IV"
      },
      {
        "label": "C",
        "text": "I、II、III"
      },
      {
        "label": "D",
        "text": "全都可以"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 247,
    "chapter": "第5章 树与二叉树",
    "question": "在有向图G 的拓扑序列中, 若顶点vi 在顶点v j 之前, 则不可能出现的情形是( )",
    "options": [
      {
        "label": "A",
        "text": "G 中有弧< vi,v j >"
      },
      {
        "label": "B",
        "text": "G 中有一条从vi 到v j 的路径"
      },
      {
        "label": "C",
        "text": "G 中没有弧< vi,v j >"
      },
      {
        "label": "D",
        "text": "G 中有一条从v j 到vi 的路径"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 248,
    "chapter": "第5章 树与二叉树",
    "question": "[图片] 以下关于拓扑排序的说法中, 错误的是( ) I.若某有向图存在环路,则该有向图一定不存在拓扑排序 II.在拓扑排序算法中为暂存入度为零的顶点,可以使用栈,也可以使用队列III.若有向图的拓扑有序序列唯一, 则图中每个顶点的入度和出度最多为1 IV.若有向图的拓扑有序序列唯一, 则图中入度为0 和出度为0 的顶点都仅有1 个",
    "options": [
      {
        "label": "A",
        "text": "I、II、IV"
      },
      {
        "label": "B",
        "text": "III、IV )"
      },
      {
        "label": "C",
        "text": "II、IV"
      },
      {
        "label": "D",
        "text": "III"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 249,
    "chapter": "第5章 树与二叉树",
    "question": "[图片] 下列关于拓扑排序的说法中, 正确的是( I.顶点数大于1 的强连通图不能进行拓扑排序II.在一个有向图的拓扑序列中, 若顶点a 在顶点b 之前, 则图中必有一条弧< a,b > III.若有向无环图的拓扑序列唯一,则可以唯一确定该图",
    "options": [
      {
        "label": "A",
        "text": "I 和II"
      },
      {
        "label": "B",
        "text": "I、II 和III"
      },
      {
        "label": "C",
        "text": "仅I"
      },
      {
        "label": "D",
        "text": "I 和III"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 250,
    "chapter": "第5章 树与二叉树",
    "question": "若一个有向图的顶点不能排成一个拓扑序列,则判定该有向图( )",
    "options": [
      {
        "label": "A",
        "text": "含有多个出度为0 的顶点"
      },
      {
        "label": "B",
        "text": "是个强连通图"
      },
      {
        "label": "C",
        "text": "含有多个入度为0 的顶点"
      },
      {
        "label": "D",
        "text": "含有顶点数大于1 的强连通分量"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 251,
    "chapter": "第5章 树与二叉树",
    "question": "[图片] 下图所示有向图的所有拓扑序列共有( ) 个。",
    "options": [
      {
        "label": "A",
        "text": "4"
      },
      {
        "label": "B",
        "text": "6"
      },
      {
        "label": "C",
        "text": "5"
      },
      {
        "label": "D",
        "text": "7"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 252,
    "chapter": "第5章 树与二叉树",
    "question": "已知有向图G = V,E , 其中V = v1,v2,v3,v4,v5,v6,v7 ,E = <v1,v2>,<v1,v3>,<v1,v4>,<v2,v5>, <v1,v2>,<v1,v3>,<v1,v4>,<v2,v5>,<v3,v5>,<v3,v6>,<v5,v7>,<v6,v7>,<v4,v6> ,G 的 拓扑序列是( )",
    "options": [
      {
        "label": "A",
        "text": " v1,v3,v4,v6,v2,v5,v7"
      },
      {
        "label": "B",
        "text": " v1,v3,v2,v6,v4,v5,v7"
      },
      {
        "label": "C",
        "text": " v1,v3,v4,v5,v2,v6,v7"
      },
      {
        "label": "D",
        "text": " v1,v2,v5,v3,v4,v6,v7"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 253,
    "chapter": "第5章 树与二叉树",
    "question": "下列哪种图的邻接矩阵是对称矩阵?( )",
    "options": [
      {
        "label": "A",
        "text": "有向网"
      },
      {
        "label": "B",
        "text": "无向图"
      },
      {
        "label": "C",
        "text": "AOV 网"
      },
      {
        "label": "D",
        "text": "AOE 网"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 254,
    "chapter": "第5章 树与二叉树",
    "question": "若一个有向图具有有序的拓扑排序序列,则它的邻接矩阵必定为( )",
    "options": [
      {
        "label": "A",
        "text": "对称"
      },
      {
        "label": "B",
        "text": "稀疏"
      },
      {
        "label": "C",
        "text": "三角"
      },
      {
        "label": "D",
        "text": "一般"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 255,
    "chapter": "第5章 树与二叉树",
    "question": "用DFS 算法遍历一个无环有向图,并在DFS 算法退栈返回时输出相应的顶点,则输出的顶点序列 是( ) B. 拓扑有序 C. 无序的 D. 无法确定",
    "options": [
      {
        "label": "A",
        "text": "逆拓扑有序    21. 下列关于图的说法中, 正确的是( ) I.有向图中顶点V 的度等于其邻接矩阵中第V 行中1 的个数II.无向图的邻接矩阵一定是对称矩阵,有向图的邻接矩阵一定是非对称矩阵III.在带权图G 的最小生成树G1 中, 某条边的权值可能会超过未选边的权值IV.若有向无环图的拓扑序列唯一,则可以唯一确定该图 A. I、II 和III"
      },
      {
        "label": "B",
        "text": "III 和IV )"
      },
      {
        "label": "C",
        "text": "III"
      },
      {
        "label": "D",
        "text": "IV"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 256,
    "chapter": "第5章 树与二叉树",
    "question": "[图片] 下图所示的AOE 网中, 关键路径长度为(",
    "options": [
      {
        "label": "A",
        "text": "16"
      },
      {
        "label": "B",
        "text": "17"
      },
      {
        "label": "C",
        "text": "18"
      },
      {
        "label": "D",
        "text": "19"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 257,
    "chapter": "第5章 树与二叉树",
    "question": "若某带权图为G = V,E , 其中V = v1,v2,v3,v4,v5,v6,v7,v8,v9,v10 ,E = {< v1,v2 > 5, < v1,v3 > 6, < v2,v5 > 3, < v3,v5 > 6, < v3,v4 > 3, < v4,v5 > 3, < v4,v7 > 1, < v4,v8 > 4, < v5,v6 > 4, < v5,v7 > 2, < v6,v10 > 4, < v7,v9 > 5,<v8,v9>2,<v9,v10>2 (注: 括号外的数据表示边上的权值), 则G 的关键 路径的长度为( )",
    "options": [
      {
        "label": "A",
        "text": "19"
      },
      {
        "label": "B",
        "text": "20"
      },
      {
        "label": "C",
        "text": "21"
      },
      {
        "label": "D",
        "text": "22"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 258,
    "chapter": "第5章 树与二叉树",
    "question": "下面关于求关键路径的说法中, 不正确的是( )",
    "options": [
      {
        "label": "A",
        "text": "求关键路径是以拓扑排序为基础的"
      },
      {
        "label": "B",
        "text": "一个事件的最早发生时间与以该事件为始的弧的活动的最早开始时间相同"
      },
      {
        "label": "C",
        "text": "一个事件的最迟发生时间是以该事件为尾的弧的活动的最迟开始时间与该活动的持续时间的差"
      },
      {
        "label": "D",
        "text": "任何一个活动的持续时间的改变可能会影响关键路径的改变"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 259,
    "chapter": "第5章 树与二叉树",
    "question": "下列关于AOE 网的关键路径的说法中, 正确的是( ) I.改变网上某一关键路径上的任意一个关键活动后,必将产生不同的关键路径II.关键路径上活动的时间延长多少,整个工期的时间也就随之延长多少III.缩短关键路径上任意一个关键活动的持续时间可缩短关键路径长度IV.缩短所有关键路径上共有的任意一个关键活动的持续时间可缩短关键路径长度V.缩短多条关键路径上共有的任意一个关键活动的持续时间可缩短关键路径长度",
    "options": [
      {
        "label": "A",
        "text": "II 和V"
      },
      {
        "label": "B",
        "text": "I、II 和IV"
      },
      {
        "label": "C",
        "text": "II 和IV"
      },
      {
        "label": "D",
        "text": "I 和IV"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 260,
    "chapter": "第5章 树与二叉树",
    "question": "在求AOE 网的关键路径时, 若该有向图用邻接矩阵表示且第i 列值全为∞, 则( )",
    "options": [
      {
        "label": "A",
        "text": "若关键路径存在, 第i 个顶点一定是起点"
      },
      {
        "label": "B",
        "text": "若关键路径存在, 第i 个顶点一定是终点"
      },
      {
        "label": "C",
        "text": "关键路径不存在"
      },
      {
        "label": "D",
        "text": "该有向图对应的无向图存在多个连通分量    27.【2010 统考真题】对下图进行拓扑排序, 可得不同拓扑序列的个数是( ) A. 4 B. 3 C. 2 D. 1 28.【2012 统考真题】下列关于最小生成树的叙述中,正确的是( ) I.最小生成树的代价唯一II.所有权值最小的边一定会出现在所有的最小生成树中III.使用Prim 算法从不同顶点开始得到的最小生成树一定相同IV.使用Prim 算法和Kruskal 算法得到的最小生成树总不相同 A. 仅I B. 仅II C. 仅I、III D. 仅II、IV 29.【2012 统考真题】对下图所示的有向带权图, 若采用Dijkstra 算法求从源点a 到其他各顶点的最短路径,则得到的第一条最短路径的目标顶点是b, 第二条最短路径的目标顶点是c, 后续得到的其余 各最短路径的目标顶点依次是( ) B. e,d,f A. d,e,f C. f ,d,e D. f ,e,d 30.【2012 统考真题】若用邻接矩阵存储有向图, 矩阵中主对角线以下的元素均为零, 则关于该图拓 扑序列的结论是( ) B. 存在,且不唯一 C. 存在,可能不唯一 D. 无法确定是否存在 A. 存在,且唯一 31.【2013 统考真题】下列AOE 网表示一项包含8 个活动的工程。通过同时加快若干活动的进度可 以缩短整个工程的工期。下列选项中,加快其进度就可以缩短工程工期的是( ) A. c 和e B. d 和c C. f 和d D. f 和h 32.【2014 统考真题】对下图所示的有向图进行拓扑排序,得到的拓扑序列可能是( ) A. 3,1,2,4,5,6 B. 3,1,2,4,6,5 C. 3,1,4,2,5,6 D. 3,1,4,2,6,5 33.【2015 统考真题】求下面的带权图的最小(代价) 生成树时, 可能是Kruskal 算法第2 次选中但不 是Prim 算法(从V4 开始) 第2 次选中的边是( )  V1,V4 A.  V1,V3 B. D.  C.  V2,V3 V3,V4    34.【2011 统考真题】下列关于图的叙述中,正确的是( ) I.回路是简单路径 II.存储稀疏图,用邻接矩阵比邻接表更省空间 III.若有向图中存在拓扑序列,则该图不存在回路 A. 仅II B. 仅I、II C. 仅III D. 仅I、III 35.【2016 统考真题】使用Dijkstra 算法求下图中从顶点1 到其他各顶点的最短路径,依次得到的各最 短路径的目标顶点是( ) B. 5,2,3,6,4 A. 5,2,3,4,6 C. 5,2,4,3,6 D. 5,2,6,3,4 36.【2016 统考真题】若对n 个顶点、e 条弧的有向图采用邻接表存储, 则拓扑排序算法的时间复杂 度是( ) A. O n B. O n+e C. O n2 D. O ne 37.【2018 统考真题】下列选项中,不是如下有向图的拓扑序列的是( ) A. 1,5,2,3,6,4 B. 5,1,2,6,3,4 C. 5,1,2,3,6,4 D. 5,2,1,6,3,4 38.【2019 统考真题】下图所示的AOE 网表示一项包含8 个活动的工程。活动d 的最早开始时间和 最迟开始时间分别是( ) /x A. 3 和7 B. 12 和12 C. 12 和14 D. 15 和15 39.【2019 统考真题】用有向无环图描述表达式x+y   x+y , 需要的顶点个数至少是( ) A. 5 B. 6 C. 8 D. 9 40.【2020 统考真题】已知无向图G 如下所示, 使用Kruskal 算法求图G 的最小生成树, 加到最小生成 树中的边依次是( ) A.  b,f , b,d , a,e , c,e , b,e B. (b, f ), (b, d), (b, e), (a, e), (c, e) C. (a, e), (b, e), (c, e), (b, d), (b, f ) D. (a, e), (c, e), (b, e), (b, f ), (b, d) 41.【2020 统考真题】修改递归方式实现的图的深度优先搜索(DFS) 算法,将输出(访问) 顶点信息的 语句移到退出递归前(即执行输出语句后立刻退出递归)。采用修改后的算法遍历有向无环图G,若 输出结果中包含G 中的全部顶点, 则输出的顶点序列是G 的( ) A. 拓扑有序序列 B. 逆拓扑有序序列 C. 广度优先搜索序列 D. 深度优先搜索序列    42.【2020 统考真题】若使用AOE 网估算工程进度, 则下列叙述中正确的是( ) A. 关键路径是从源点到汇点边数最多的一条路径B. 关键路径是从源点到汇点路径长度最长的路径C. 增加任意一个关键活动的时间不会延长工程的工期D. 缩短任意一个关键活动的时间将会缩短工程的工期 43.【2021 统考真题】给定如下有向图, 该图的拓扑有序序列的个数是( ) A. 1 B. 2 C. 3 D. 4 44.【2021 统考真题】使用Dijkstra 算法求下图中从顶点1 到其余各顶点的最短路径,将当前找到的从顶点1 到顶点2,3,4,5 的最短路径长度保存在数组dist 中, 求出第二条最短路径后, dist 中的内容更新 为( ) B. 25,3,14,6 A. 26,3,14,6 C. 21,3,14,6 D. 15,3,14,6 45.【2022 统考真题】下图是一个有10 个活动的AOE 网, 时间余量最大的活动是( ) A. c B. g C. h D. j 46.【2023 统考真题】已知无向连通图G 中各边的权值均为1。在下列算法中, 一定能够求出图G 中 从某顶点到其余各顶点最短路径的是( ) I. Prim 算法 II. Kruskal 算法 III.图的广度优先搜索算法 A. 仅I B. 仅III C. 仅I、II D. I、II、III"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 261,
    "chapter": "第7章 查找",
    "question": "顺序查找适合于存储结构为( ) 的线性表。 B. 散列存储结构",
    "options": [
      {
        "label": "A",
        "text": "顺序存储结构或链式存储结构 C. 索引存储结构 D. 压缩存储结构 2. 由n 个数据元素组成的两个表: 一个递增有序, 一个无序。采用顺序查找算法, 对有序表从头开始查找,发现当前元素已不小于待查元素时,停止查找,确定查找不成功,已知查找任一元素的概率是相 同的,则在两种表中成功查找( )"
      },
      {
        "label": "B",
        "text": "平均时间两者相同 A. 平均时间后者小"
      },
      {
        "label": "C",
        "text": "平均时间前者小"
      },
      {
        "label": "D",
        "text": "无法确定"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 262,
    "chapter": "第7章 查找",
    "question": "[图片] 对长度为n 的有序单链表, 若查找每个元素的概率相等, 则顺序查找表中任意一个元素的查找成功 的平均查找长度为( ) B.  n+1 /2 C.  n-1 /2 D. n/4",
    "options": [
      {
        "label": "A",
        "text": "n/2 4. 对长度为3 的顺序表进行查找, 若查找第一个元素的概率为1/2, 查找第二个元素的概率为1/3, 查 找第三个元素的概率为1/6, 则查找任一元素的平均查找长度为( ) D. 4/3 A. 5/3"
      },
      {
        "label": "B",
        "text": "2"
      },
      {
        "label": "C",
        "text": "7/3 5. 下列关于二分查找的叙述中,正确的是( ) A. 表必须有序,表可以顺序方式存储,也可以链表方式存储B. 表必须有序且表中数据必须是整型、实型或字符型C. 表必须有序,而且只能从小到大排列"
      },
      {
        "label": "D",
        "text": "表必须有序,且表只能以顺序方式存储"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 263,
    "chapter": "第7章 查找",
    "question": "在一个顺序存储的有序线性表上查找一个数据时,既可以采用折半查找,也可以采用顺序查找,但前者比后者的查找速度( )",
    "options": [
      {
        "label": "A",
        "text": "必然快"
      },
      {
        "label": "B",
        "text": "取决于表是递增还是递减"
      },
      {
        "label": "C",
        "text": "在大部分情况下要快"
      },
      {
        "label": "D",
        "text": "必然不快"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 264,
    "chapter": "第7章 查找",
    "question": "折半查找过程所对应的判定树是一棵( ) D. 满二叉树 时, 被比",
    "options": [
      {
        "label": "A",
        "text": "最小生成树"
      },
      {
        "label": "B",
        "text": "平衡二叉树"
      },
      {
        "label": "C",
        "text": "完全二叉树 8. 折半查找和二叉排序树的时间性能( )"
      },
      {
        "label": "D",
        "text": "无法比较 A. 相同 B. 有时不相同 C. 完全不同"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 265,
    "chapter": "第7章 查找",
    "question": "在有11 个元素的有序表A 1,2,⋯,11 中进行折半查找⌊low+high /2⌋ 查找元素A 11 较的元素下标依次是( ) D. 6,8,9,11",
    "options": [
      {
        "label": "A",
        "text": "6,8,10,11"
      },
      {
        "label": "B",
        "text": "6,9,10,11"
      },
      {
        "label": "C",
        "text": "6,7,9,11    10. 已知有序表(13,18,24,35,47,50,62,83,90,115,134), 当二分查找值为90 的元素时, 查找成功的比 较次数为( ) B. 2 C. 4"
      },
      {
        "label": "D",
        "text": "6 A. 1"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 266,
    "chapter": "第7章 查找",
    "question": "若有序表的关键字序列为{b,c,d,e,f ,g,q,r,s,t}, 则在二分查找关键字b 的过程中, 进行比较的关 键字依次为( ) ) D. g,d,b - 1",
    "options": [
      {
        "label": "A",
        "text": "f ,c,b"
      },
      {
        "label": "B",
        "text": "f ,d,b"
      },
      {
        "label": "C",
        "text": "g,c,b 12. 对表长为n 的有序表进行折半查找, 其判定树的高度为("
      },
      {
        "label": "D",
        "text": " log2n A.  log2 n+1 B.  log2 n+1 - 1 C.  log2n"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 267,
    "chapter": "第7章 查找",
    "question": "已知一个长度为16 的顺序表,其元素按关键字有序排列,若采用折半查找算法查找一个不存在的 元素,则比较的次数至少是( ), 至多是( ) C. 6 D. 7",
    "options": [
      {
        "label": "A",
        "text": "4"
      },
      {
        "label": "B",
        "text": "5 14. 具有12 个关键字的有序表中,对每个关键字的查找概率相同,折半查找算法查找成功的平均查找 长度为( ), 折半查找查找失败的平均查找长度为( ) D. 49/13 A. 37/12 B. 35/12"
      },
      {
        "label": "C",
        "text": "39/13 15. 下列关于查找的说法中, 正确的是( ) (注: 本题涉及下节内容)。 A. 若数据元素保持有序,则查找时就可以采用折半查找法 B. 折半查找与二叉查找树的时间性能在最坏情况下是相同的 C. 折半查找法的平均查找长度一定小于顺序查找法"
      },
      {
        "label": "D",
        "text": "折半查找法查找一个元素大约需要O log2n 次关键字比较"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 268,
    "chapter": "第7章 查找",
    "question": "采用分块查找时,数据的组织方式为( )",
    "options": [
      {
        "label": "A",
        "text": "数据分成若干块,每块内数据有序"
      },
      {
        "label": "B",
        "text": "数据分成若干块,每块内数据不必有序,但块间必须有序,每块内最大(或最小) 的数据组成索引块"
      },
      {
        "label": "C",
        "text": "数据分成若干块,每块内数据有序,每块内最大(或最小) 的数据组成索引块,"
      },
      {
        "label": "D",
        "text": "数据分成若干块,每块(除最后一块外) 中数据个数需相同"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 269,
    "chapter": "第7章 查找",
    "question": "对有2500 个记录的索引顺序表(分块表) 进行查找,最理想的块长为( )  log22500",
    "options": [
      {
        "label": "A",
        "text": "50"
      },
      {
        "label": "B",
        "text": "125"
      },
      {
        "label": "C",
        "text": "500"
      },
      {
        "label": "D",
        "text": "1"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 270,
    "chapter": "第7章 查找",
    "question": "设顺序存储的某线性表共有123 个元素,按分块查找的要求等分为3 块。若对索引表采用顺序查 找法来确定子块,且在确定的子块中也采用顺序查找法,则在等概率情况下,分块查找成功的平均查找 长度为( ) B. 23 C. 41 D. 62",
    "options": [
      {
        "label": "A",
        "text": "21    19. 为提高查找效率,对有65025 个元素的有序顺序表建立索引顺序结构,在最好情况下查找到表中已 有元素最多需要执行( ) 次关键字比较。 C. 16 D. 21 A. 10"
      },
      {
        "label": "B",
        "text": "14 20.【2010 统考真题】已知一个长度为16 的顺序表L,其元素按关键字有序排列,若采用折半查找法查 找一个L 中不存在的元素, 则关键字的比较次数最多是( ) A. 4 B. 5"
      },
      {
        "label": "C",
        "text": "6"
      },
      {
        "label": "D",
        "text": "7 21.【2015 统考真题】下列选项中, 不能构成折半查找中关键字比较序列的是( ) A. 500,200,450,180 B. 500, 450, 200, 180 C. 180,500,200,450 D. 180,200,500,450 22.【2016 统考真题】在有n n>1000 个元素的升序数组A 中查找关键字x。查找算法的伪代码如 下所示。 本算法与折半查找算法相比, 有可能具有更少比较次数的情形是( ) ) A. 当x 不在数组中 B. 当x 接近数组开头处 C. 当x 接近数组结尾处 D. 当x 位于数组中间位置 23.【2017 统考真题】下列二叉树中, 可能成为折半查找判定树(不含外部结点) 的是( 24.【2023 统考真题】对含600 个元素的有序顺序表进行折半查找,关键字间的比较次数最多是( ) A. 9 B. 10 C. 30 D. 300 25.【2024 统考真题】下列数据结构中,不适合直接使用折半查找的是( ) I.有序链表II.无序数组III.有序静态链表IV.无序静态链表 A. 仅I、III B. 仅II、IV C. 仅II、III、IV D. I、II、III、IV"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 271,
    "chapter": "第7章 查找",
    "question": "对于二叉排序树,下面的说法中, ( ) 是正确的。",
    "options": [
      {
        "label": "A",
        "text": "二叉排序树是动态树表,查找失败时插入新结点,会引起树的重新分裂和组合"
      },
      {
        "label": "B",
        "text": "对二叉排序树进行层序遍历可得到有序序列"
      },
      {
        "label": "C",
        "text": "用逐点插入法构造二叉排序树,若先后插入的关键字有序,二叉排序树的深度最大"
      },
      {
        "label": "D",
        "text": "在二叉排序树中进行查找, 关键字的比较次数不超过结点数的1/2"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 272,
    "chapter": "第7章 查找",
    "question": "按( ) 遍历二叉排序树得到的序列是一个有序序列。",
    "options": [
      {
        "label": "A",
        "text": "先序"
      },
      {
        "label": "B",
        "text": "中序"
      },
      {
        "label": "C",
        "text": "后序"
      },
      {
        "label": "D",
        "text": "层次"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 273,
    "chapter": "第7章 查找",
    "question": "在二叉排序树中进行查找的效率与( ) 有关。",
    "options": [
      {
        "label": "A",
        "text": "二叉排序树的深度"
      },
      {
        "label": "B",
        "text": "二叉排序树的结点的个数"
      },
      {
        "label": "C",
        "text": "被查找结点的度"
      },
      {
        "label": "D",
        "text": "二叉排序树的存储结构"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 274,
    "chapter": "第7章 查找",
    "question": "在常用的描述二叉排序树的存储结构中,关键字值最大的结点( )",
    "options": [
      {
        "label": "A",
        "text": "左指针一定为空"
      },
      {
        "label": "B",
        "text": "右指针一定为空"
      },
      {
        "label": "C",
        "text": "左右指针均为空"
      },
      {
        "label": "D",
        "text": "左右指针均不为空"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 275,
    "chapter": "第7章 查找",
    "question": "设二叉排序树中关键字由1 到1000 的整数构成,现要查找关键字为363 的结点,下述关键字序列中, 不可能是在二叉排序树上杳找的序列是( )",
    "options": [
      {
        "label": "A",
        "text": "2,252,401,398,330,344,397,363"
      },
      {
        "label": "B",
        "text": "924, 220, 911, 244, 898, 258, 362, 363"
      },
      {
        "label": "C",
        "text": "925, 202, 911, 240, 912, 245, 363"
      },
      {
        "label": "D",
        "text": "2, 399, 387, 219, 266, 382, 381, 278, 363"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 276,
    "chapter": "第7章 查找",
    "question": "分别以下列序列构造二叉排序树,与用其他3 个序列所构造的结果不同的是( )",
    "options": [
      {
        "label": "A",
        "text": "(100,80,90,60,120,110,130)"
      },
      {
        "label": "B",
        "text": "(100,120,110,130,80,60,90)"
      },
      {
        "label": "C",
        "text": "(100,60,80,90,120,110,130)"
      },
      {
        "label": "D",
        "text": "(100,80,60,90,120,130,110)"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 277,
    "chapter": "第7章 查找",
    "question": "从空树开始,依次插入元素52, 26, 14, 32, 71, 60, 93, 58, 24 和41 后构成了一棵二叉排序树。在该树 查找60 要进行比较的次数为( )",
    "options": [
      {
        "label": "A",
        "text": "3"
      },
      {
        "label": "B",
        "text": "4"
      },
      {
        "label": "C",
        "text": "5"
      },
      {
        "label": "D",
        "text": "6"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 278,
    "chapter": "第7章 查找",
    "question": "在含有n 个结点的二叉排序树中查找某个关键字的结点时, 最多进行( ) 次比较。",
    "options": [
      {
        "label": "A",
        "text": "n/2"
      },
      {
        "label": "B",
        "text": "log2n"
      },
      {
        "label": "C",
        "text": "log2n + 1"
      },
      {
        "label": "D",
        "text": "n"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 279,
    "chapter": "第7章 查找",
    "question": "五个不同结点构造的二叉查找树的形态共有( ) 种。",
    "options": [
      {
        "label": "A",
        "text": "20"
      },
      {
        "label": "B",
        "text": "30"
      },
      {
        "label": "C",
        "text": "32"
      },
      {
        "label": "D",
        "text": "42"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 280,
    "chapter": "第7章 查找",
    "question": "构造一棵具有n 个结点的二叉排序树时, 最理想情况下的深度为( )",
    "options": [
      {
        "label": "A",
        "text": "n/2"
      },
      {
        "label": "B",
        "text": "n"
      },
      {
        "label": "C",
        "text": " log2 n+1"
      },
      {
        "label": "D",
        "text": " log2 n+1"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 281,
    "chapter": "第7章 查找",
    "question": "含有20 个结点的平衡二叉树的最大深度为( ) ) D. 7",
    "options": [
      {
        "label": "A",
        "text": "4"
      },
      {
        "label": "B",
        "text": "5"
      },
      {
        "label": "C",
        "text": "6 12. 具有5 层结点的平衡二叉树至少有( ) 个结点。"
      },
      {
        "label": "D",
        "text": "17 A. 10 B. 12 C. 15"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 282,
    "chapter": "第7章 查找",
    "question": "高度为3 的平衡二叉排序树的形态共有( ) 种。 D. 15",
    "options": [
      {
        "label": "A",
        "text": "13"
      },
      {
        "label": "B",
        "text": "14"
      },
      {
        "label": "C",
        "text": "16 14. 在平衡二叉树的基本操作中,可能发生两次旋转的操作是("
      },
      {
        "label": "D",
        "text": "都不会 A. 添加、删除结点 B. 仅删除结点 C. 仅添加结点"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 283,
    "chapter": "第7章 查找",
    "question": "将关键字1,2,3, ⋯,1024 依次插入到初始为空的平衡二叉树中, 假设只有一个根结点的二叉树的 高度为0,则插入结束后的平衡二叉树的高度是( ) ) D. 11",
    "options": [
      {
        "label": "A",
        "text": "8"
      },
      {
        "label": "B",
        "text": "9"
      },
      {
        "label": "C",
        "text": "10 16. 下列关于红黑树和AVL 树的说法中, 不正确的是( I.一棵含有n 个结点的红黑树的高度至多为2log2 n+1 II.如果一个结点是红色的,则它的父结点和孩子结点都是黑色的III.红黑树的查询效率一般要优于含有相同结点数的AVL 树IV.若AVL 树的某结点的左右孩子的平衡因子都是零,则该结点的平衡因子也是零 A. I、III B. III C. II、IV"
      },
      {
        "label": "D",
        "text": "III、IV"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 284,
    "chapter": "第7章 查找",
    "question": "下列关于红黑树和AVL 树的描述中,不正确的是( )",
    "options": [
      {
        "label": "A",
        "text": "两者都属于自平衡的二叉树"
      },
      {
        "label": "B",
        "text": "两者查找、插入、删除的时间复杂度都相同"
      },
      {
        "label": "C",
        "text": "红黑树插入和删除过程至多有2 次旋转操作"
      },
      {
        "label": "D",
        "text": "红黑树的任意一个结点的左右子树高度(含叶结点) 之比不超过2"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 285,
    "chapter": "第7章 查找",
    "question": "下列关于红黑树的说法中, 正确的是( )",
    "options": [
      {
        "label": "A",
        "text": "红黑树的红结点的数目最多和黑结点的数目相同"
      },
      {
        "label": "B",
        "text": "若红黑树的所有结点都是黑色的,那么它一定是一棵满二叉树"
      },
      {
        "label": "C",
        "text": "红黑树的任何一个分支结点都有两个非空孩子结点"
      },
      {
        "label": "D",
        "text": "红黑树的子树也一定是红黑树"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 286,
    "chapter": "第7章 查找",
    "question": "下列四个选项中,满足红黑树定义的是( ) 20. 将关键字1,2,3,4,5,6,7 依次插入初始为空的红黑树T, 则T 中红结点的个数是( )",
    "options": [
      {
        "label": "A",
        "text": "1"
      },
      {
        "label": "B",
        "text": "2"
      },
      {
        "label": "C",
        "text": "3"
      },
      {
        "label": "D",
        "text": "4"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 287,
    "chapter": "第7章 查找",
    "question": "[图片] 将关键字5,4,3,2,1 依次插入初始为空的红黑树T, 则T 的最终形态是( ) 22. 在下图所示的红黑树中插入结点2 且染成红色后,则下一步应进行的操作是( ) [图有些不清晰，各节点层排序值为8,5,12,3,null,10,14]",
    "options": [
      {
        "label": "A",
        "text": "左旋"
      },
      {
        "label": "B",
        "text": "右旋"
      },
      {
        "label": "C",
        "text": "变色"
      },
      {
        "label": "D",
        "text": "无须调整    23.【2009 统考真题】下列二叉排序树中, 满足平衡二叉树定义的是( ) 24.【2010 统考真题】在下图所示的平衡二叉树中插入关键字48 后得到一棵新平衡二叉树,在新平衡 二叉树中, 关键字37 所在结点的左、右子结点中保存的关键字分别是( ) A. 13,48 B. 24,48 C. 24,53 D. 24,90 25.【2011 统考真题】对下列关键字序列,不可能构成某二叉排序树中一条查找路径的是( ) A. 95, 22, 91, 24, 94, 71 B. 92, 20, 91, 34, 88, 35 C. 21,89,77,29,36,38 D. 12, 25, 71, 68, 33, 34 26.【2012 统考真题】若平衡二叉树的高度为6, 且所有非叶结点的平衡因子均为1,则该平衡二叉树 的结点总数为( ) B. 20 C. 32 D. 33 A. 12 27.【2013 统考真题】在任意一棵非空二叉排序树T1 中, 删除某结点v 之后形成二叉排序树T2, 再 将v 插入T2 形成二叉排序树T3。下列关于T1 与T3 的叙述中,正确的是( ) I.若v 是T1 的叶结点, 则T1 与T3 不同 II.若v 是T1 的叶结点, 则T1 与T3 相同 III.若v 不是T1 的叶结点, 则T1 与T3 不同 IV.若v 不是T1 的叶结点, 则T1 与T3 相同 A. 仅I、III B. 仅I、IV C. 仅II、III D. 仅II、IV 28.【2013 统考真题】若将关键字1,2,3,4,5,6,7 依次插入初始为空的平衡二叉树T, 则T 中平衡因子 为0 的分支结点的个数是( ) C. 2 D. 3 A. 0 B. 1 29.【2015 统考真题】现有一棵无重复关键字的平衡二叉树(AVL),对其进行中序遍历可得到一个降 序序列。下列关于该平衡二叉树的叙述中, 正确的是( ) ) A. 根结点的度一定为2 B. 树中最小元素一定是叶结点 C. 最后插入的元素一定是叶结点 D. 树中最大元素一定是无左子树 30.【2018 统考真题】已知二叉排序树如下图所示, 元素之间应满足的大小关系是( A. x1 < x2 < x5 B. x1 < x4 < x5 C. x3 < x5 < x4 D. x4 < x3 < x5    31.【2019 统考真题】在任意一棵非空平衡二叉树(AVL 树)T1 中, 删除某结点v 之后形成平衡二叉树T2, 再将v 插入T2 形成平衡二叉树T3。下列关于T1 与T3 的叙述中, 正确的是( ) I.若v 是T1 的叶结点, 则T1 与T3 可能不相同II.若v 不是T1 的叶结点, 则T1 与T3 一定不相同III.若v 不是T1 的叶结点, 则T1 与T3 一定相同 A. 仅I B. 仅II C. 仅I、II D. 仅I、III 32.【2020 统考真题】下列给定的关键字输入序列中, 不能生成下边二叉排序树的是( ) A. 4,5,2,1,3 B. 4,5,1,2,3 C. 4,2,5,3,1 D. 4,2,1,3,5 33.【2021 统考真题】给定平衡二叉树如下图所示, 插入关键字23 后, 根中的关键字是( ) A. 16 B. 20 C. 23 D. 25 34.【2024 统考真题】一棵二叉搜索树如下图所示, k1,k2,k3 分别是对应结点中保存的关键字。子树T 的任意一个结点中保存的关键字x 满足的是( ) A. x < k1 B. x > k2 C. k1 < x < k3 D. k3 < x < k2 7.4B 树与B + 树(答案见原书页码P317)"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 288,
    "chapter": "第7章 查找",
    "question": "[图片] 下图所示是一棵( ) B. 3 阶B 树",
    "options": [
      {
        "label": "A",
        "text": "4 阶B 树 C. 4 阶B + 树 D. 无法确定 2. 下列关于m 阶B 树的说法中, 错误的是( ) A. 根结点至多有m 棵子树"
      },
      {
        "label": "B",
        "text": "所有叶结点都在同一层次上"
      },
      {
        "label": "C",
        "text": "非叶结点至少有m/2(m 为偶数) 或m+1 /2(m 为奇数) 棵子树"
      },
      {
        "label": "D",
        "text": "根结点中的数据是有序的"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 289,
    "chapter": "第7章 查找",
    "question": "以下关于高度为3 的3 阶B 树的说法中,正确的是( ) I.每个结点至少有两棵非空子树II.树中每个结点至多有2 个关键字III.树中最多能存储26 个关键字IV.插入一个元素引起B 树结点分裂后, 树的高度变为4",
    "options": [
      {
        "label": "A",
        "text": "I、II"
      },
      {
        "label": "B",
        "text": "II、III"
      },
      {
        "label": "C",
        "text": "III、IV"
      },
      {
        "label": "D",
        "text": "I、II、IV"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 290,
    "chapter": "第7章 查找",
    "question": "在一棵m 阶B 树中做插入操作前, 若一个结点中的关键字个数等于( ), 则插入操作后必须分裂 成两个结点; 在一棵m 阶的B 树中做删除操作前, 若一个结点中的关键字个数等于( ), 则删除操作 后可能需要同它的左兄弟或右兄弟结点合并成一个结点。",
    "options": [
      {
        "label": "A",
        "text": "m, ⌈m/2 ⌉-2"
      },
      {
        "label": "B",
        "text": "m - 1, ⌈m/2 ⌉-1"
      },
      {
        "label": "C",
        "text": "m + 1, ⌈m/2 ⌉"
      },
      {
        "label": "D",
        "text": "m/2, ⌈m/2 ⌉+1 + 1"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 291,
    "chapter": "第7章 查找",
    "question": "具有n 个关键字的m 阶B 树, 应有( ) 个叶结点。",
    "options": [
      {
        "label": "A",
        "text": "n + 1"
      },
      {
        "label": "B",
        "text": "n - 1"
      },
      {
        "label": "C",
        "text": "nm"
      },
      {
        "label": "D",
        "text": "nm/2"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 292,
    "chapter": "第7章 查找",
    "question": "高度为5 的3 阶B 树至少有( ) 个结点,至多有( ) 个结点。",
    "options": [
      {
        "label": "A",
        "text": "32"
      },
      {
        "label": "B",
        "text": "31"
      },
      {
        "label": "C",
        "text": "120"
      },
      {
        "label": "D",
        "text": "121"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 293,
    "chapter": "第7章 查找",
    "question": "含有n 个非叶结点的m 阶B 树中至少包含( ) 个关键字。",
    "options": [
      {
        "label": "A",
        "text": "n m+1"
      },
      {
        "label": "B",
        "text": "n"
      },
      {
        "label": "C",
        "text": "n ⌈m/2⌉-1"
      },
      {
        "label": "D",
        "text": " n-1  ⌈m/2⌉-1"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 294,
    "chapter": "第7章 查找",
    "question": "已知一棵5 阶B 树中共有53 个关键字, 则树的最大高度为( ), 最小高度为( )",
    "options": [
      {
        "label": "A",
        "text": "2"
      },
      {
        "label": "B",
        "text": "3"
      },
      {
        "label": "C",
        "text": "4"
      },
      {
        "label": "D",
        "text": "5"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 295,
    "chapter": "第7章 查找",
    "question": "已知一棵3 阶B 树中有2047 个关键字,则树的最大高度为( ),最小高度为( )",
    "options": [
      {
        "label": "A",
        "text": "11"
      },
      {
        "label": "B",
        "text": "10"
      },
      {
        "label": "C",
        "text": "8"
      },
      {
        "label": "D",
        "text": "7"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 296,
    "chapter": "第7章 查找",
    "question": "在7 阶B 树中搜索第2016 个关键字,若根结点已读入内存,则最多需启动( ) 次I/O。",
    "options": [
      {
        "label": "A",
        "text": "4"
      },
      {
        "label": "B",
        "text": "5"
      },
      {
        "label": "C",
        "text": "6"
      },
      {
        "label": "D",
        "text": "7"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 297,
    "chapter": "第7章 查找",
    "question": "在一棵高度为h 的B 树中插入一个新关键字, 假设在插入过程中读入的结点一直在内存中, 根结点的高度为1,且初始时未读入内存,则下列叙述中错误的是( ) (注意,本题中的新结点是指新产生的结点,如一次分裂才产生一个新结点)",
    "options": [
      {
        "label": "A",
        "text": "若插入操作导致树的高度变为h + 1, 则本次插入一定导致了根结点的分裂"
      },
      {
        "label": "B",
        "text": "若插入操作导致旧结点的分裂, 则树的高度一定会变为h + 1"
      },
      {
        "label": "C",
        "text": "由于本次插入操作而产生的新结点的个数最多为h + 1"
      },
      {
        "label": "D",
        "text": "由于本次插入操作而产生的读/ 写磁盘的次数最多为3h + 1"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 298,
    "chapter": "第7章 查找",
    "question": "下列关于B 树和B + 树的叙述中,错误的是( )",
    "options": [
      {
        "label": "A",
        "text": "B 树和B + 树都能有效地支持顺序查找"
      },
      {
        "label": "B",
        "text": "B 树和B + 树都能有效地支持随机查找"
      },
      {
        "label": "C",
        "text": "B 树和B + 树都是平衡的多叉树"
      },
      {
        "label": "D",
        "text": "B 树和B + 树都可以用于文件索引结构"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 299,
    "chapter": "第7章 查找",
    "question": "下列关于B 树和B + 树的查找操作的叙述中,错误的是( )",
    "options": [
      {
        "label": "A",
        "text": "B 树查找成功时,不一定需要查找到最后一层的内部结点"
      },
      {
        "label": "B",
        "text": "B 树查找失败时,一定需要查找到叶结点"
      },
      {
        "label": "C",
        "text": "B + 树查找成功时,不一定需要查找到叶结点"
      },
      {
        "label": "D",
        "text": "B + 树查找成功时,每次查找的长度都相等    14.【2009 统考真题】下列叙述中, 不符合m 阶B 树定义要求的是( ) A. 根结点至多有m 棵子树 B. 所有叶结点都在同一层上 C. 各结点内关键字均升序或降序排列 D. 叶结点之间通过指针链接 15.【2012 统考真题】已知一棵3 阶B 树, 如下图所示。删除关键字78 得到一棵新B 树,其最右叶结 点中的关键字是( ) B. 60,62 A. 60 C. 62,65 D. 65 16.【2013 统考真题】在一棵高度为2 的5 阶B 树中,所含关键字的个数至少是( ) A. 5 B. 7 C. 8 D. 14 17.【2014 统考真题】在一棵有15 个关键字的4 阶B 树中,含关键字的结点个数最多是( ) A. 5 B. 6 C. 10 D. 15 18.【2016 统考真题】B + 树不同于B 树的特点之一是( ) A. 能支持顺序查找 B. 结点中含有关键字 C. 根结点至少有两个分支 D. 所有叶结点都在同一层上 19.【2017 统考真题】下列应用中,适合使用B + 树的是( ) A. 编译器中的词法分析 B. 关系数据库系统中的索引 C. 网络中的路由表快速查找 D. 操作系统的磁盘空闲块管理 20.【2018 统考真题】高度为5 的3 阶B 树含有的关键字个数至少是( ) A. 15 B. 31 C. 62 D. 242 21.【2020 统考真题】依次将关键字5, 6, 9, 13, 8, 2, 12, 15 插入初始为空的4 阶B 树后,根结点中包含 的关键字是( ) B. 6,9 C. 8,13 D. 9,12 A. 8 22.【2021 统考真题】在一棵高度为3 的3 阶B 树中,根为第1 层,若第2 层中有4 个关键字,则该树的 结点数最多是( ) B. 10 C. 9 D. 8 A. 11 23.【2022 统考真题】在下图所示的5 阶B 树T 中, 删除关键字260 之后需要进行必要的调整, 得到新的B 树T1 下列选项中, 不可能是T1 根结点中关键字序列的是( ) A. 60,90,280 C. 60,85,110,350 B. 60,90,350 D. 60,90,110,350    24.【2023 统考真题】下列关于非空B 树的叙述中,正确的是( ) I.插入操作可能增加树的高度 II.删除操作一定会导致叶结点的变化 III.查找某关键字总是要查找到叶结点 IV.插入的新关键字最终位于叶结点中 A. 仅I B. 仅I、II C. 仅III、IV D. 仅I、II、IV"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 300,
    "chapter": "第7章 查找",
    "question": "只能在顺序存储结构上进行的查找方法是( )",
    "options": [
      {
        "label": "A",
        "text": "顺序查找法"
      },
      {
        "label": "B",
        "text": "折半查找法"
      },
      {
        "label": "C",
        "text": "树型查找法"
      },
      {
        "label": "D",
        "text": "散列查找法"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 301,
    "chapter": "第7章 查找",
    "question": "散列查找一般适用于( ) 的情况下的查找。 B. 查找表为有序表D. 关键字集合与地址集合之间存在对应关系",
    "options": [
      {
        "label": "A",
        "text": "查找表为链表C. 关键字集合比地址集合大得多 3. 下列关于散列表的说法中, 正确的是( ) I.若散列表的填装因子α < 1, 则可避免碰撞的产生 II.散列查找中不需要任何关键字的比较 III.散列表在查找成功时平均查找长度仅与表长有关IV.若在散列表中删除一个元素, 不能简单地将该元素删除 A. I 和IV"
      },
      {
        "label": "B",
        "text": "II 和III"
      },
      {
        "label": "C",
        "text": "III"
      },
      {
        "label": "D",
        "text": "IV"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 302,
    "chapter": "第7章 查找",
    "question": "在开放定址法中散列到同一个地址而引起的“堆积”问题是由于( ) 引起的。",
    "options": [
      {
        "label": "A",
        "text": "同义词之间发生冲突"
      },
      {
        "label": "B",
        "text": "非同义词之间发生冲突"
      },
      {
        "label": "C",
        "text": "同义词之间或非同义词之间发生冲突"
      },
      {
        "label": "D",
        "text": "散列表“溢出”"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 303,
    "chapter": "第7章 查找",
    "question": "[图片] 下列关于散列冲突处理方法的说法中, 正确的有( ) I.采用平方探测法处理冲突时不易产生聚集II.采用线性探测法处理冲突时, 所有同义词在散列表中一定相邻III.采用链地址法处理冲突时, 若限定在链首插入, 则插入任意一个元素的时间是相同的 IV.采用链地址法处理冲突易引起聚集现象",
    "options": [
      {
        "label": "A",
        "text": "I 和III"
      },
      {
        "label": "B",
        "text": "I、II 和III"
      },
      {
        "label": "C",
        "text": "III 和IV"
      },
      {
        "label": "D",
        "text": "I 和IV"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 304,
    "chapter": "第7章 查找",
    "question": "设有一个含有200 个表项的散列表,用线性探测法解决冲突,按关键字查询时找到一个表项的平均 探测次数不超过1.5, 则散列表项应能够容纳( ) 个表项(设查找成功的平均查找长度为ASL = ) 次  1+1/ 1-α /2, 其中α 为装填因子)。",
    "options": [
      {
        "label": "A",
        "text": "400"
      },
      {
        "label": "B",
        "text": "526"
      },
      {
        "label": "C",
        "text": "624"
      },
      {
        "label": "D",
        "text": "676"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 305,
    "chapter": "第7章 查找",
    "question": "假定有K 个关键字互为同义词, 若用线性探测法把这K 个关键字填入散列表, 至少要进行( 探测。",
    "options": [
      {
        "label": "A",
        "text": "K - 1"
      },
      {
        "label": "B",
        "text": "K"
      },
      {
        "label": "C",
        "text": "K + 1"
      },
      {
        "label": "D",
        "text": "K K+1 /2"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 306,
    "chapter": "第7章 查找",
    "question": "对包含n 个元素的散列表进行查找, 平均查找长度( )",
    "options": [
      {
        "label": "A",
        "text": "为O log2n"
      },
      {
        "label": "B",
        "text": "为O 1"
      },
      {
        "label": "C",
        "text": "不直接依赖于n"
      },
      {
        "label": "D",
        "text": "直接依赖于表长m"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 307,
    "chapter": "第7章 查找",
    "question": "采用开放定址法解决冲突的散列查找中, 发生聚集的原因主要是( )",
    "options": [
      {
        "label": "A",
        "text": "数据元素过多"
      },
      {
        "label": "B",
        "text": "负载因子过大"
      },
      {
        "label": "C",
        "text": "散列函数选择不当"
      },
      {
        "label": "D",
        "text": "解决冲突的方法选择不当"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 308,
    "chapter": "第7章 查找",
    "question": "当用线性探测再散列法解决冲突时, 计算出的一系列“下一个空位”的要求是( )",
    "options": [
      {
        "label": "A",
        "text": "必须大于或等于原散列地址"
      },
      {
        "label": "B",
        "text": "必须小于或等于原散列地址"
      },
      {
        "label": "C",
        "text": "可以大于或小于但不等于原散列地址"
      },
      {
        "label": "D",
        "text": "对地址在何处没有限制"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 309,
    "chapter": "第7章 查找",
    "question": "一组记录的关键字为{19,14,23,1,68,20,84,27,55,11,10,79}, 用链地址法构造散列表, 散列函数 为H key = keymod13, 散列地址为1 的链中有( ) 个记录。 D. 4",
    "options": [
      {
        "label": "A",
        "text": "1"
      },
      {
        "label": "B",
        "text": "2"
      },
      {
        "label": "C",
        "text": "3 12. 在采用链地址法处理冲突所构成的散列表上查找某一关键字,则在查找成功的情况下,所探测的这 些位置上的关键字值( )；若采用线性探测法, 则( ) 个链表。这些链的链 A. 一定都是同义词 B. 不一定都是同义词 C. 都相同"
      },
      {
        "label": "D",
        "text": "一定都不是同义词"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 310,
    "chapter": "第7章 查找",
    "question": "若采用链地址法构造散列表, 散列函数为H key = key mod 17, 则需① 首指针构成一个指针数组,数组的下标范围为(②)。 ①",
    "options": [
      {
        "label": "A",
        "text": "17"
      },
      {
        "label": "B",
        "text": "13"
      },
      {
        "label": "C",
        "text": "16"
      },
      {
        "label": "D",
        "text": "任意 ②A. 0 ∼17 B. 1 ∼17 C. 0 ∼16 D. 1 ∼16"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 311,
    "chapter": "第7章 查找",
    "question": "[图片] 设散列表长m = 14, 散列函数为H key = key%11, 表中仅有4 个结点H 15 = 4,H 38 = 5, H 61 = 6,H 84 = 7, 若采用线性探测法处理冲突, 则关键字为49 的结点地址是( )",
    "options": [
      {
        "label": "A",
        "text": "8"
      },
      {
        "label": "B",
        "text": "3"
      },
      {
        "label": "C",
        "text": "5"
      },
      {
        "label": "D",
        "text": "9"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 312,
    "chapter": "第7章 查找",
    "question": "现有长度为17、初始为空的散列表HT, 散列函数H key = key%17, 用线性探查法解决冲突。将 关键字序列26, 25, 72, 38, 8, 18, 59 依次插入HT 后,则查找59 需探查( ) 次。",
    "options": [
      {
        "label": "A",
        "text": "2"
      },
      {
        "label": "B",
        "text": "3"
      },
      {
        "label": "C",
        "text": "4"
      },
      {
        "label": "D",
        "text": "5"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 313,
    "chapter": "第7章 查找",
    "question": "[图片] 现有长度为17、初始为空的散列表HT, 散列函数H key = key%17, 用平方探测法解决冲突: Hi key = H key ±i2 %17。17。将关键字序列6,22,7,26,9,23 依次插入HT 后, 则关键字23 存放 在散列表中的位置是( )",
    "options": [
      {
        "label": "A",
        "text": "0"
      },
      {
        "label": "B",
        "text": "2"
      },
      {
        "label": "C",
        "text": "6"
      },
      {
        "label": "D",
        "text": "15"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 314,
    "chapter": "第7章 查找",
    "question": "[图片] 将10 个元素散列到100000 个单元的散列表中,则( ) 产生冲突。",
    "options": [
      {
        "label": "A",
        "text": "一定会"
      },
      {
        "label": "B",
        "text": "一定不会"
      },
      {
        "label": "C",
        "text": "仍可能会"
      },
      {
        "label": "D",
        "text": "不确定    18.【2011 统考真题】为提高散列表的查找效率, 可以采取的正确措施是( ) I.增大装填(载) 因子II.设计冲突(碰撞) 少的散列函数III.处理冲突(碰撞) 时避免产生聚集(堆积) 现象 A. 仅I B. 仅II C. 仅I、II D. 仅II、III 19.【2014 统考真题】用哈希(散列) 方法处理冲突(碰撞) 时可能出现堆积(聚集) 现象,下列选项中, 会受堆积现象直接影响的是( ) A. 存储效率 B. 散列函数 C. 装填(装载) 因子 D. 平均查找长度 20.【2018 统考真题】现有长度为7、初始为空的散列表HT, 散列函数H k = k%7, 用线性探测再散 列法解决冲突。将关键字22,43,15 依次插入HT 后, 查找成功的平均查找长度是( ) A."
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 315,
    "chapter": "第8章 排序",
    "question": "下述排序方法中, 不属于内部排序方法的是( ) D. 冒泡排序",
    "options": [
      {
        "label": "A",
        "text": "插入排序"
      },
      {
        "label": "B",
        "text": "选择排序"
      },
      {
        "label": "C",
        "text": "拓扑排序 2. 排序算法的稳定性是指( ) A. 经过排序后,能使关键字相同的元素保持原顺序中的相对位置不变B. 经过排序后,能使关键字相同的元素保持原顺序中的绝对位置不变C. 排序算法的性能与被排序元素个数关系不大"
      },
      {
        "label": "D",
        "text": "排序算法的性能与被排序元素的个数关系密切"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 316,
    "chapter": "第8章 排序",
    "question": "下列关于排序的叙述中,正确的是( )",
    "options": [
      {
        "label": "A",
        "text": "稳定的排序方法优于不稳定的排序方法"
      },
      {
        "label": "B",
        "text": "对同一线性表使用不同的排序方法进行排序,得到的排序结果可能不同"
      },
      {
        "label": "C",
        "text": "排序方法都是在顺序表上实现的,在链表上无法实现排序方法"
      },
      {
        "label": "D",
        "text": "在顺序表上实现的排序方法在链表上也可以实现"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 317,
    "chapter": "第8章 排序",
    "question": "对5 个不同的数据元素进行直接插入排序,最多需要进行的比较次数是( )",
    "options": [
      {
        "label": "A",
        "text": "8"
      },
      {
        "label": "B",
        "text": "10"
      },
      {
        "label": "C",
        "text": "15"
      },
      {
        "label": "D",
        "text": "25"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 318,
    "chapter": "第8章 排序",
    "question": "在待排序的元素序列基本有序的前提下,效率最高的排序方法是( )",
    "options": [
      {
        "label": "A",
        "text": "直接插入排序"
      },
      {
        "label": "B",
        "text": "简单选择排序"
      },
      {
        "label": "C",
        "text": "快速排序"
      },
      {
        "label": "D",
        "text": "归并排序"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 319,
    "chapter": "第8章 排序",
    "question": "在图书馆中,计算机类书籍区共有12 列书架,书架上的书都是按照编号排列好的,其中有些书被读者放错了地方, 但通常不超过一个书架。未来将这些书重新放回正确的位置, 应该采用何种排序算 法？( ) ); 在",
    "options": [
      {
        "label": "A",
        "text": "堆排序"
      },
      {
        "label": "B",
        "text": "直接插入排序"
      },
      {
        "label": "C",
        "text": "归并排序"
      },
      {
        "label": "D",
        "text": "简单选择排序"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 320,
    "chapter": "第8章 排序",
    "question": "对有n 个元素的顺序表采用直接插入排序算法进行排序, 在最坏情况下所需的比较次数是( 最好情况下所需的比较次数是( )",
    "options": [
      {
        "label": "A",
        "text": "n - 1"
      },
      {
        "label": "B",
        "text": "n + 1"
      },
      {
        "label": "C",
        "text": "n/2"
      },
      {
        "label": "D",
        "text": "n n-1 /2"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 321,
    "chapter": "第8章 排序",
    "question": "数据序列{8,10,13,4,6,7,22,2,3} 只能是( ) 两趟排序后的结果。",
    "options": [
      {
        "label": "A",
        "text": "简单选择排序"
      },
      {
        "label": "B",
        "text": "起泡排序"
      },
      {
        "label": "C",
        "text": "直接插入排序"
      },
      {
        "label": "D",
        "text": "堆排序"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 322,
    "chapter": "第8章 排序",
    "question": "用直接插入排序算法对下列4 个表进行(从小到大) 排序,比较次数最少的是( )",
    "options": [
      {
        "label": "A",
        "text": "94,32,40,90,80,46,21,69"
      },
      {
        "label": "B",
        "text": "21,32,46,40,80,69,90,94"
      },
      {
        "label": "C",
        "text": "32,40,21,46,69,94,90,80"
      },
      {
        "label": "D",
        "text": "90,69,80,46,21,32,94,40"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 323,
    "chapter": "第8章 排序",
    "question": "在下列算法中,( ) 算法可能出现下列情况: 在最后一趟开始之前, 所有元素都不在最终位置上。",
    "options": [
      {
        "label": "A",
        "text": "堆排序"
      },
      {
        "label": "B",
        "text": "冒泡排序"
      },
      {
        "label": "C",
        "text": "直接插入排序"
      },
      {
        "label": "D",
        "text": "快速排序"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 324,
    "chapter": "第8章 排序",
    "question": "希尔排序属于( )",
    "options": [
      {
        "label": "A",
        "text": "插入排序"
      },
      {
        "label": "B",
        "text": "交换排序"
      },
      {
        "label": "C",
        "text": "选择排序"
      },
      {
        "label": "D",
        "text": "归并排序"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 325,
    "chapter": "第8章 排序",
    "question": "对序列{15,9,7,8,20, -1,4} 采用希尔排序, 经一趟后变为{15, -1,4,8,20,9,7}, 则该次采用的增量 是( )",
    "options": [
      {
        "label": "A",
        "text": "1"
      },
      {
        "label": "B",
        "text": "4"
      },
      {
        "label": "C",
        "text": "3"
      },
      {
        "label": "D",
        "text": "2"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 326,
    "chapter": "第8章 排序",
    "question": "若序列{15,9,7,8,20, -1,4} 经一趟排序后序列变成{9,15,7,8,20, -1,4}, 则采用的是下列的( )",
    "options": [
      {
        "label": "A",
        "text": "选择排序"
      },
      {
        "label": "B",
        "text": "快速排序"
      },
      {
        "label": "C",
        "text": "直接插入排序"
      },
      {
        "label": "D",
        "text": "冒泡排序"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 327,
    "chapter": "第8章 排序",
    "question": "对序列{98,36, -9,0,47,23,1,8,10,7} 采用希尔排序, 下列序列( ) 是增量为4 的一趟排序结果。",
    "options": [
      {
        "label": "A",
        "text": "{10,7, -9,0,47,23,1,8,98,36}"
      },
      {
        "label": "B",
        "text": "{-9,0,36,98,1,8,23,47,7,10}"
      },
      {
        "label": "C",
        "text": "{36,98, -9,0,23,47,1,8,7,10}"
      },
      {
        "label": "D",
        "text": "以上都不对"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 328,
    "chapter": "第8章 排序",
    "question": "对序列{E,A,S,Y,Q,U,E,S,T,I,O,N} 按照字典顺序排序, 采用增量d = 6,3,1 的希尔排序算法。 则前两趟排序后, 关键字的总比较次数为( ) C. 16 D. 18",
    "options": [
      {
        "label": "A",
        "text": "15"
      },
      {
        "label": "B",
        "text": "17 13. 已知输入序列{13,24,7,1,8,9,11,56,34,51,2,77,5}, 增量序列d = 5,3,1, 采用希尔排序算法进行排 序,则两趟排序后的结果为( ) A. 1,7,8,9,13,24,11,34,51,2,5,56,77 B. 1,7,5,2,8,9,24,11,34,51,13,77,56"
      },
      {
        "label": "C",
        "text": "2,11,5,1,8,9,24,7,34,51,13,77,56"
      },
      {
        "label": "D",
        "text": "2,5,11,1,8,9,7,24,34,13,51,77,56"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 329,
    "chapter": "第8章 排序",
    "question": "折半插入排序算法的时间复杂度为( )",
    "options": [
      {
        "label": "A",
        "text": "O n"
      },
      {
        "label": "B",
        "text": "O nlog2n"
      },
      {
        "label": "C",
        "text": "O n2"
      },
      {
        "label": "D",
        "text": "O n3"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 330,
    "chapter": "第8章 排序",
    "question": "有些排序算法在每趟排序过程中,都会有一个元素被放置到其最终位置上, ( ) 算法不会出现此 种情况。",
    "options": [
      {
        "label": "A",
        "text": "希尔排序"
      },
      {
        "label": "B",
        "text": "堆排序"
      },
      {
        "label": "C",
        "text": "冒泡排序"
      },
      {
        "label": "D",
        "text": "快速排序"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 331,
    "chapter": "第8章 排序",
    "question": "以下排序算法中, 不稳定的是( ) C. 希尔排序 D. 归并排序",
    "options": [
      {
        "label": "A",
        "text": "冒泡排序"
      },
      {
        "label": "B",
        "text": "直接插入排序 17. 以下排序算法中, 稳定的是( )"
      },
      {
        "label": "C",
        "text": "直接插入排序"
      },
      {
        "label": "D",
        "text": "简单选择排序 A. 快速排序 B. 堆排序    18.【2012 统考真题】对同一待排序序列分别进行折半插入排序和直接插入排序,两者之间可能的不 同之处是( ) A. 排序的总趟数 B. 元素的移动次数 C. 使用辅助空间的数量 D. 元素之间的比较次数 19.【2014 统考真题】用希尔排序方法对一个数据序列进行排序时, 若第1 趟排序结果为9,1,4,13,7, 8,20, 23, 15,则该趟排序采用的增量(间隔) 可能是( ) D. 5 D. 归并排序 A. 2 B. 3 C. 4 20.【2015 统考真题】希尔排序的组内排序采用的是( ) A. 直接插入排序 B. 折半插入排序 C. 快速排序 21.【2018 统考真题】对初始数据序列(8,3,9,11,2,1,4,7,5,10,6) 进行希尔排序。若第一趟排序结果 为(1,3,7,5,2,6,4,9,11,10,8), 第二趟排序结果为(1,2,6,4,3,7,5,8,11,10,9), 则两趟排序采用的增量 (间隔) 依次是( ) B. 3,2 C. 5,2 D. 5,3 A. 3,1"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 332,
    "chapter": "第8章 排序",
    "question": "对n 个不同的元素利用冒泡法从小到大排序, 在( ) 情况下元素交换的次数最多。",
    "options": [
      {
        "label": "A",
        "text": "从大到小排列好的"
      },
      {
        "label": "B",
        "text": "从小到大排列好的"
      },
      {
        "label": "C",
        "text": "元素无序"
      },
      {
        "label": "D",
        "text": "元素基本有序"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 333,
    "chapter": "第8章 排序",
    "question": "若用冒泡排序算法对序列{10,14,26,29,41,52} 从大到小排序, 则需进行( ) 次比较。",
    "options": [
      {
        "label": "A",
        "text": "3"
      },
      {
        "label": "B",
        "text": "10"
      },
      {
        "label": "C",
        "text": "15"
      },
      {
        "label": "D",
        "text": "25"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 334,
    "chapter": "第8章 排序",
    "question": "用某种排序方法对线性表{25,84,21,47,15,27,68,35,20} 进行排序时, 元素序列的变化情况如下: 1)25,84,21,47,15,27,68,35,203)15,20,21,25,35,27,47,68,84 2)20,15,21,25,47,27,68,35,844)15,20,21,25,27,35,47,68,84 则所采用的排序方法是( ) C. 2 路归并排序 D. 快速排序",
    "options": [
      {
        "label": "A",
        "text": "选择排序"
      },
      {
        "label": "B",
        "text": "插入排序 4. 一组记录的关键码为(46,79,56,38,40,84), 则利用快速排序的方法, 以第一个记录为基准, 从小到 大得到的一次划分结果为( ) A. (38,40,46,56,79,84) B. (40,38,46,79,56,84)"
      },
      {
        "label": "C",
        "text": "(40,38,46,56,79,84)"
      },
      {
        "label": "D",
        "text": "(40,38,46,84,56,79)"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 335,
    "chapter": "第8章 排序",
    "question": "快速排序算法在( ) 情况下最不利于发挥其长处。",
    "options": [
      {
        "label": "A",
        "text": "要排序的数据量太大"
      },
      {
        "label": "B",
        "text": "要排序的数据中含有多个相同值"
      },
      {
        "label": "C",
        "text": "要排序的数据个数为奇数"
      },
      {
        "label": "D",
        "text": "要排序的数据已基本有序"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 336,
    "chapter": "第8章 排序",
    "question": "就平均性能而言,目前最好的内部排序方法是( ) D. 快速排序) 两趟排序后的结果。 D. 插入排序",
    "options": [
      {
        "label": "A",
        "text": "冒泡排序"
      },
      {
        "label": "B",
        "text": "直接插入排序"
      },
      {
        "label": "C",
        "text": "希尔排序 7. 数据序列F = {2,1,4,9,8,10,6,20} 只能是下列排序算法中的( A. 快速排序 B. 冒泡排序 C. 选择排序 8. 对数据序列{8,9,10,4,5,6,20,1,2} 采用冒泡排序(从后向前次序进行, 要求升序), 需要进行的趟数 至少是( ) (不考虑无元素交换的最后一趟) C. 5"
      },
      {
        "label": "D",
        "text": "8 A. 3 B. 4"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 337,
    "chapter": "第8章 排序",
    "question": "双向冒泡排序是指对一个序列在正反两个方向交替进行扫描,第一趟把最大值放在序列的最右端, 第二趟把最小值放在序列的最左端,之后在缩小的范围内进行同样的扫描,放在次右端、次左端,直至 序列有序。对数组{4,7,8,3,5,6,10,9,1,2} 进行双向冒泡排序, 则排序趟数是( ) (第一趟从左往右 开始,从左往右或从右往左都称为一趟)。",
    "options": [
      {
        "label": "A",
        "text": "7"
      },
      {
        "label": "B",
        "text": "6"
      },
      {
        "label": "C",
        "text": "8"
      },
      {
        "label": "D",
        "text": "9 )"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 338,
    "chapter": "第8章 排序",
    "question": "对下列关键字序列用快排进行排序时, 速度最快的情形是( ), 速度最慢的情形是(",
    "options": [
      {
        "label": "A",
        "text": "{21,25,5,17,9,23,30}"
      },
      {
        "label": "B",
        "text": "{25,23,30,17,21,5,9}"
      },
      {
        "label": "C",
        "text": "{21,9,17,30,25,23,5}"
      },
      {
        "label": "D",
        "text": "{5,9,17,21,23,25,30}"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 339,
    "chapter": "第8章 排序",
    "question": "对下列4 个序列,以第一个关键字为基准用快速排序算法进行排序,在第一趟过程中移动记录次数 最多的是( )",
    "options": [
      {
        "label": "A",
        "text": "92,96,88,42,30,35,110,100"
      },
      {
        "label": "B",
        "text": "92,96,100,110,42,35,30,88"
      },
      {
        "label": "C",
        "text": "100,96,92,35,30,110,88,42"
      },
      {
        "label": "D",
        "text": "42,30,35,92,100,96,88,110"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 340,
    "chapter": "第8章 排序",
    "question": "下列序列中,( ) 可能是执行第一趟快速排序后所得到的序列(按从大到小排序和从小到大排序 分别计论)。 I. {68,11,18,69,23,93,73}III. {93,73,68,11,69,23,18} II. {68,11,69,23,18,93,73}IV. {68,11,69,23,18,73,93}",
    "options": [
      {
        "label": "A",
        "text": "I、IV"
      },
      {
        "label": "B",
        "text": "II、III"
      },
      {
        "label": "C",
        "text": "III、IV"
      },
      {
        "label": "D",
        "text": "只有IV"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 341,
    "chapter": "第8章 排序",
    "question": "对n 个关键字进行快速排序, 最大递归深度为( ), 最小递归深度为( )",
    "options": [
      {
        "label": "A",
        "text": "1"
      },
      {
        "label": "B",
        "text": "n"
      },
      {
        "label": "C",
        "text": "log2n"
      },
      {
        "label": "D",
        "text": "nlog2n"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 342,
    "chapter": "第8章 排序",
    "question": "对8 个元素的序列进行快速排序,在最好情况下的关键字比较次数是( )",
    "options": [
      {
        "label": "A",
        "text": "7"
      },
      {
        "label": "B",
        "text": "8"
      },
      {
        "label": "C",
        "text": "12"
      },
      {
        "label": "D",
        "text": "13    15.【2010 统考真题】采用递归方式对顺序表进行快速排序。下列关于递归次数的叙述中,正确的是 ( ) A. 递归次数与初始数据的排列次序无关 B. 每次划分后,先处理较长的分区可以减少递归次数 C. 每次划分后,先处理较短的分区可以减少递归次数 D. 递归次数与每次划分后得到的分区的处理顺序无关 16.【2011 统考真题】为实现快速排序算法,待排序序列宜采用的存储方式是( ) A. 顺序存储 B. 散列存储 C. 链式存储 D. 索引存储 17.【2014 统考真题】下列选项中,不可能是快速排序第2 趟排序结果的是( ) A. 2,3,5,4,6,7,9 B. 2,7,5,6,4,3,9 C. 3,2,5,4,7,6,9 D. 4,2,3,5,7,6,9 18.【2019 统考真题】排序过程中, 对尚未确定最终位置的所有元素进行一遍处理称为一“趟”。下列 序列中, 不可能是快速排序第二趟结果的是( ) A. 5,2,16,12,28,60,32,72 B. 2,16,5,28,12,60,32,72 C. 2,12,16,5,28,32,72,60 D. 5,2,12,28,16,32,72,60 19.【2023 统考真题】使用快速排序算法对数据进行升序排序,若经过一次划分后得到的数据序列是 68, 11, 70,23,80,77,48,81,93,88, 则该次划分的枢轴是( ) A. 11 B. 70 C. 80 D. 81 20.【2024 统考真题】使用快速排序算法对含n n≥3 个元素的数组M 进行排序, 若第一趟排序将M 中除枢轴外的n - 1 个元素划分为均不为空的P 和Q 两块, 则下列叙述中, 正确的是( ) A. P 与Q 块间有序 B. P 与Q 均块内有序 C. P 和的元素个数大致相等 D. P 中和Q 中均不存在相等的元素"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 343,
    "chapter": "第8章 排序",
    "question": "在以下排序算法中,每次从未排序的记录中选取最小关键字的记录,加入已排序记录的末尾,该排序 方法是( )",
    "options": [
      {
        "label": "A",
        "text": "简单选择排序"
      },
      {
        "label": "B",
        "text": "冒泡排序"
      },
      {
        "label": "C",
        "text": "堆排序"
      },
      {
        "label": "D",
        "text": "直接插入排序"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 344,
    "chapter": "第8章 排序",
    "question": "简单选择排序算法的比较次数和移动次数分别为( )",
    "options": [
      {
        "label": "A",
        "text": "O n ,O log2n"
      },
      {
        "label": "B",
        "text": "O log2n ,O n2"
      },
      {
        "label": "C",
        "text": "O n2 ,O n"
      },
      {
        "label": "D",
        "text": "O nlog2n ,O n"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 345,
    "chapter": "第8章 排序",
    "question": "若只想得到100000 个元素组成的序列中第10 个最小元素之前的部分排序的序列,用( ) 方法最 快。",
    "options": [
      {
        "label": "A",
        "text": "冒泡排序"
      },
      {
        "label": "B",
        "text": "快速排序"
      },
      {
        "label": "C",
        "text": "希尔排序"
      },
      {
        "label": "D",
        "text": "堆排序"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 346,
    "chapter": "第8章 排序",
    "question": "下列( ) 是一个堆。",
    "options": [
      {
        "label": "A",
        "text": "19,75,34,26,97,56"
      },
      {
        "label": "B",
        "text": "97, 26, 34, 75, 19, 56"
      },
      {
        "label": "C",
        "text": "19,56,26,97,34,75"
      },
      {
        "label": "D",
        "text": "19,34,26,97,56,75"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 347,
    "chapter": "第8章 排序",
    "question": "在含有n 个关键字的小根堆中(下标从1 开始), 关键字最大的记录有可能存储在( ) 位置",
    "options": [
      {
        "label": "A",
        "text": "n/2"
      },
      {
        "label": "B",
        "text": "n/2 + 2"
      },
      {
        "label": "C",
        "text": "1"
      },
      {
        "label": "D",
        "text": "n/2 - 1"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 348,
    "chapter": "第8章 排序",
    "question": "向具有n 个结点的堆中插入一个新元素的时间复杂度为( ), 删除一个元素的时间复杂度为( )",
    "options": [
      {
        "label": "A",
        "text": "O 1"
      },
      {
        "label": "B",
        "text": "O n"
      },
      {
        "label": "C",
        "text": "O log2n"
      },
      {
        "label": "D",
        "text": "O nlog2n"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 349,
    "chapter": "第8章 排序",
    "question": "构建n 个记录的初始堆, 其时间复杂度为( ); 对n 个记录进行堆排序, 最坏情况下其时间复杂度 为( )",
    "options": [
      {
        "label": "A",
        "text": "O n"
      },
      {
        "label": "B",
        "text": "O n2"
      },
      {
        "label": "C",
        "text": "O log2n"
      },
      {
        "label": "D",
        "text": "O nlog2n"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 350,
    "chapter": "第8章 排序",
    "question": "下列4 种排序算法中,排序过程中的比较次数与序列初始状态无关的是( )",
    "options": [
      {
        "label": "A",
        "text": "简单选择排序"
      },
      {
        "label": "B",
        "text": "直接插入排序"
      },
      {
        "label": "C",
        "text": "快速排序"
      },
      {
        "label": "D",
        "text": "冒泡排序"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 351,
    "chapter": "第8章 排序",
    "question": "对由相同的n 个整数构成的二叉排序树和小根堆, 下列说法中不正确的是( )",
    "options": [
      {
        "label": "A",
        "text": "二叉排序树的高度大于或等于小根堆的高度"
      },
      {
        "label": "B",
        "text": "对二叉排序树进行中序遍历可以得到从小到大的序列"
      },
      {
        "label": "C",
        "text": "从小根堆的根结点到任意叶结点的路径构成从小到大的序列"
      },
      {
        "label": "D",
        "text": "对小根堆进行层序遍历可以得到从小到大的序列"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 352,
    "chapter": "第8章 排序",
    "question": "有一组数据(15,9,7,8,20, -1,7,4), 用堆排序的筛选方法建立的初始小根堆为( ) )",
    "options": [
      {
        "label": "A",
        "text": "- 1,4,8,9,20,7,15,7"
      },
      {
        "label": "B",
        "text": "- 1,7,15,7,4,8,20,9"
      },
      {
        "label": "C",
        "text": "- 1,4,7,8,20,15,7,9"
      },
      {
        "label": "D",
        "text": "A、B、C 均不对"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 353,
    "chapter": "第8章 排序",
    "question": "对关键字序列{23,17,72,60,25,8,68,71,52} 进行堆排序, 输出两个最小关键码后的剩余堆是(",
    "options": [
      {
        "label": "A",
        "text": "{23,72,60,25,68,71,52}"
      },
      {
        "label": "B",
        "text": "{23,25,52,60,71,72,68}"
      },
      {
        "label": "C",
        "text": "{71,25,23,52,60,72,68}"
      },
      {
        "label": "D",
        "text": "{23,25,68,52,60,72,71}"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 354,
    "chapter": "第8章 排序",
    "question": "堆排序分为两个阶段: 第一阶段将给定的序列构造成一个初始堆,第二阶段逐次输出堆顶元素,并调整使其保持堆的性质。设有给定序列{48,62,35,77,55,14,35,98}, 若在堆排序的第一阶段将该序 列构造成一个大根堆,则交换元素的次数为( ) C. 7 D. 8",
    "options": [
      {
        "label": "A",
        "text": "5"
      },
      {
        "label": "B",
        "text": "6 13. 已知大根堆{62,34,53,12,8,46,22}, 删除堆顶元素后需要重新调整堆, 则在此过程中关键字的比 较次数为( ) B. 3"
      },
      {
        "label": "C",
        "text": "4"
      },
      {
        "label": "D",
        "text": "5 A. 2"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 355,
    "chapter": "第8章 排序",
    "question": "从根结点到任意叶结点的路径都是有序的数据结构是( ) D. 堆",
    "options": [
      {
        "label": "A",
        "text": "红黑树"
      },
      {
        "label": "B",
        "text": "二叉查找树"
      },
      {
        "label": "C",
        "text": "哈夫曼树 15.【2009 统考真题】已知关键字序列{5,8,12,19,28,20,15,22} 是小根堆, 插入关键字3, 调整好后得 到的小根堆是( ) A. 3,5,12,8,28,20,15,22,19 B. 3,5,12,19,20,15,22,8,28 C. 3,8,12,5,20,15,22,28,19"
      },
      {
        "label": "D",
        "text": "3,12,5,8,28,20,15,22,19 16.【2011 统考真题】已知序列{25,13,10,12,9} 是大根堆, 在序列尾部插入新元素18, 将其再调整为 大根堆,调整过程中元素之间进行的比较次数是( ) A. 1 B. 2 C. 4 D. 5 17.【2015 统考真题】已知小根堆为{8,15,10,21,34,16,12}, 删除关键字8 之后需重建堆, 在此过程 中, 关键字之间的比较次数是( ) ) A. 1 B. 2 C. 3 D. 4 18.【2018 统考真题】在将序列{6,1,5,9,8,4,7)} 建成大根堆时, 正确的序列变化过程是( A. 6,1,7,9,8,4,5 →6,9,7,1,8,4,5 →9,6,7,1,8,4,5 →9,8,7,1,6,4,5 B. 6,9,5,1,8,4,7 →6,9,7,1,8,4,5 →9,6,7,1,8,4,5 →9,8,7,1,6,4,5 C. 6,9,5,1,8,4,7 →9,6,5,1,8,4,7 →9,6,7,1,8,4,5 →9,8,7,1,6,4,5 D. 6,1,7,9,8,4,5 →7,1,6,9,8,4,5 →7,9,6,1,8,4,5 →9,7,6,1,8,4,5 →9,8,6,1,7,4,5 19.【2020 统考真题】下列关于大根堆(至少含2 个元素) 的叙述中, 正确的是( ) I.可以将堆视为一棵完全二叉树III.可以将堆视为一棵二叉排序树 II.可以采用顺序存储方式保存堆IV.堆中的次大值一定在根的下一层 A. 仅I、II B. 仅II、III C. 仅I、II 和IV D. I、III 和IV ) 20.【2021 统考真题】将关键字6,9,1,5,8,4,7 依次插入到初始为空的大根堆H 中, 得到的H 是( A. 9,8,7,6,5,4,1 B. 9,8,7,5,6,1,4 C. 9,8,7,5,6,4,1 D. 9,6,7,5,8,4,1 21.【2024 统考真题】已知关键字序列28,22,20,19,8,12,15,5 是大根堆(最大堆), 对该堆进行两次删 除操作后,得到的新堆是( ) C. 20,19,12,15,8,5 D. 20,19,8,12,15,5 A. 20,19,15,12,8,5 B. 20,19,15,5,8,12"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 356,
    "chapter": "第8章 排序",
    "question": "以下排序方法中,(",
    "options": [
      {
        "label": "A",
        "text": "简单选择排序 2. 以下排序算法中,( A. 快速排序 ) 在一趟结束后不一定能选出一个元素放在其最终位置上。"
      },
      {
        "label": "B",
        "text": "冒泡排序"
      },
      {
        "label": "C",
        "text": "归并排序"
      },
      {
        "label": "D",
        "text": "堆排序 ) 不需要进行关键字的比较。 B. 归并排序 C. 基数排序 D. 堆排序"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 357,
    "chapter": "第8章 排序",
    "question": "在下列排序算法中, 平均情况下空间复杂度为O n 的是( ); 最坏情况下空间复杂度为O n 的 ) 是( ) I.希尔排序 II.堆排序 III.冒泡排序 IV.归并排序 V.快速排序 VI.基数排序",
    "options": [
      {
        "label": "A",
        "text": "I、IV、VI"
      },
      {
        "label": "B",
        "text": "II、V"
      },
      {
        "label": "C",
        "text": "IV、V"
      },
      {
        "label": "D",
        "text": "IV"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 358,
    "chapter": "第8章 排序",
    "question": "下列排序方法中, 排序过程中比较次数的数量级与序列初始状态无关的是( )",
    "options": [
      {
        "label": "A",
        "text": "归并排序"
      },
      {
        "label": "B",
        "text": "插入排序"
      },
      {
        "label": "C",
        "text": "快速排序"
      },
      {
        "label": "D",
        "text": "冒泡排序"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 359,
    "chapter": "第8章 排序",
    "question": "二路归并排序中, 归并趟数的数量级是( )",
    "options": [
      {
        "label": "A",
        "text": "O n"
      },
      {
        "label": "B",
        "text": "O log2n"
      },
      {
        "label": "C",
        "text": "O nlog2n"
      },
      {
        "label": "D",
        "text": "O n2"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 360,
    "chapter": "第8章 排序",
    "question": "若对27 个元素只进行三趟多路归并排序,则选取的归并路数最少为( )",
    "options": [
      {
        "label": "A",
        "text": "2"
      },
      {
        "label": "B",
        "text": "3"
      },
      {
        "label": "C",
        "text": "4"
      },
      {
        "label": "D",
        "text": "5"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 361,
    "chapter": "第8章 排序",
    "question": "将两个各有N 个元素的有序表合并成一个有序表, 最少的比较次数是( ), 最多的比较次数是(",
    "options": [
      {
        "label": "A",
        "text": "N"
      },
      {
        "label": "B",
        "text": "2N - 1"
      },
      {
        "label": "C",
        "text": "2N"
      },
      {
        "label": "D",
        "text": "N - 1"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 362,
    "chapter": "第8章 排序",
    "question": "用归并排序算法对序列{1,2,6,4,5,3,8,7} 进行排序, 共需要进行( ) 次比较",
    "options": [
      {
        "label": "A",
        "text": "12"
      },
      {
        "label": "B",
        "text": "13"
      },
      {
        "label": "C",
        "text": "14"
      },
      {
        "label": "D",
        "text": "15"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 363,
    "chapter": "第8章 排序",
    "question": "一组经过第一趟二路归并排序后的记录的关键字为{25,50,15,35,80,85,20,40,36,70}, 其中包含5 个长度为2 的有序表,用二路归并排序方法对该序列进行第二趟归并后的结果为( ) )",
    "options": [
      {
        "label": "A",
        "text": "15,25,35,50,80,20,85,40,70,36"
      },
      {
        "label": "B",
        "text": "15,25,35,50,20,40,80,85,36,70"
      },
      {
        "label": "C",
        "text": "15,25,50,35,80,85,20,36,40,70"
      },
      {
        "label": "D",
        "text": "15,25,35,50,80,20,36,40,70,85"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 364,
    "chapter": "第8章 排序",
    "question": "若将中国人按照生日(不考虑年份, 只考虑月、日) 来排序, 则使用下列排序算法时, 最快的是(",
    "options": [
      {
        "label": "A",
        "text": "归并排序"
      },
      {
        "label": "B",
        "text": "希尔排序"
      },
      {
        "label": "C",
        "text": "快速排序"
      },
      {
        "label": "D",
        "text": "基数排序"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 365,
    "chapter": "第8章 排序",
    "question": "[图片] 设线性表中每个元素有两个数据项k1 和k2, 现对线性表按以下规则进行排序: 先看数据项k1,k1值小的元素在前, 大的元素在后, 在k1 值相同的情况下, 再看k2,k2 值小的元素在前, 大的元素在后。 满足这种要求的排序算法是( )",
    "options": [
      {
        "label": "A",
        "text": "先按k1 进行直接插入排序, 再按k2 进行简单选择排序"
      },
      {
        "label": "B",
        "text": "先按k2 进行直接插入排序, 再按k1 进行简单选择排序"
      },
      {
        "label": "C",
        "text": "先按k1 进行简单选择排序, 再按k2 进行直接插入排序"
      },
      {
        "label": "D",
        "text": "先按k2 进行简单选择排序, 再按k1 进行直接插入排序"
      }
    ],
    "answer": null,
    "subject": "数据结构",
    "hasImage": true
  },
  {
    "id": 366,
    "chapter": "第8章 排序",
    "question": "对{05,46,13,55,94,17,42} 进行基数排序, 一趟排序的结果是( )",
    "options": [
      {
        "label": "A",
        "text": "05,46,13,55,94,17,42"
      },
      {
        "label": "B",
        "text": "05,13,17,42,46,55,94"
      },
      {
        "label": "C",
        "text": "42,13,94,05,55,46,17"
      },
      {
        "label": "D",
        "text": "05, 13, 46, 55, 17, 42, 94"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 367,
    "chapter": "第8章 排序",
    "question": "有n 个十进制整数进行基数排序, 其中最大的整数为5 位, 则基数排序过程中临时建立的队列个 数是( ) D. 10 D. 插入排序",
    "options": [
      {
        "label": "A",
        "text": "n"
      },
      {
        "label": "B",
        "text": "2"
      },
      {
        "label": "C",
        "text": "5 14. 下列各种排序算法中,( ) 需要的附加存储空间最大。 A. 快速排序 B. 堆排序 C. 归并排序 15.【2013 统考真题】已知两个长度分别为m 和n 的升序链表, 若将它们合并为长度为m + n 的一个 降序链表,则最坏情况下的时间复杂度是( ) C. O(min m,n"
      },
      {
        "label": "D",
        "text": "O max m,n A. O n B. O mn 16.【2013 统考真题】对给定的关键字序列110, 119, 007, 911, 114, 120, 122 进行基数排序,第2 趟分配 收集后得到的关键字序列是( ) A. 007, 110, 119, 114, 911, 120, 122 B. 007, 110, 119, 114, 911, 122, 120 C. 007, 110, 911, 114, 119, 120, 122 D. 110, 120, 911, 122, 114, 007, 119 17.【2015 统考真题】下列排序算法中, 元素的移动次数与关键字的初始状态无关的是( ) A. 直接插入排序 B. 冒泡排序 C. 基数排序 D. 快速排序 18.【2021 统考真题】设数组S = {93,946,372,9,146,151,301,485,236,327,43,892}, 采用最低位优 先(LSD) 基数排序将S 排列成升序序列。第一趟分配、收集后, 元素372 之前、之后紧邻的元素分 别是( ) B. 236,301 C. 301, 892 D. 485,301 A. 43,892 19.【2022 统考真题】使用二路归并排序对含n 个元素的数组M 进行排序时, 二路归并操作的功能是(A.将两个有序表合并为一个新的有序表B.将M 划分为两部分, 两部分的元素个数大致相等C.将M 划分为n 个部分, 每个部分中仅含有一个元素D.将M 划分为两部分, 一部分元素的值均小于另一部分元素的值 20.【2024 统考真题】现有由关键字组成的3 个有序序列3,5、7,9和(6), 若按从左至右的次序选择有序序列进行二路归并排序,则关键字之间的总比较次数是( ) A. 3 B. 4 C. 5 D. 6"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 368,
    "chapter": "第8章 排序",
    "question": "若要求排序是稳定的,且关键字为实数,则在下列排序方法中应选( ) D. 快速排序",
    "options": [
      {
        "label": "A",
        "text": "直接插入排序"
      },
      {
        "label": "B",
        "text": "选择排序"
      },
      {
        "label": "C",
        "text": "基数排序 2. 以下排序方法中时间复杂度为O nlog2n 且稳定的是( )"
      },
      {
        "label": "D",
        "text": "直接插入排序 A. 堆排序 B. 快速排序 C. 归并排序"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 369,
    "chapter": "第8章 排序",
    "question": "设被排序的结点序列共有n 个结点, 在该序列中的结点已十分接近有序的情况下, 用直接插入排 序、归并排序和快速排序对其进行排序,这些算法的时间复杂度应为( )",
    "options": [
      {
        "label": "A",
        "text": "O n ,O n ,O n"
      },
      {
        "label": "B",
        "text": "O n ,O nlog2n ,O nlog2n"
      },
      {
        "label": "C",
        "text": "O n ,O nlog2n ,O n2"
      },
      {
        "label": "D",
        "text": "O n2 ,O nlog2n ,O n2"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 370,
    "chapter": "第8章 排序",
    "question": "下列排序算法中属于稳定排序的是(①), 平均时间复杂度为O nlog2n 的是(②), 在最好的情况下, 时间复杂度可以达到线性时间的有(③) (注: 多选题) I.冒泡排序 II.堆排序 III.选择排序 IV.直接插入排序 V.希尔排序 VI.归并排序 VII.快速排序 5. 就排序算法所用的辅助空间而言,堆排序、快速排序和归并排序的关系是( )",
    "options": [
      {
        "label": "A",
        "text": "堆排序< 快速排序< 归并排序"
      },
      {
        "label": "B",
        "text": "堆排序< 归并排序< 快速排序"
      },
      {
        "label": "C",
        "text": "堆排序> 归并排序> 快速排序"
      },
      {
        "label": "D",
        "text": "堆排序> 快速排序> 归并排序"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 371,
    "chapter": "第8章 排序",
    "question": "排序趟数与序列的初始状态无关的排序方法是( ) I.直接插入排序II.简单选择排序III.冒泡排序IV.基数排序",
    "options": [
      {
        "label": "A",
        "text": "I、III"
      },
      {
        "label": "B",
        "text": "II、IV"
      },
      {
        "label": "C",
        "text": "I、II、IV"
      },
      {
        "label": "D",
        "text": "I、IV"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 372,
    "chapter": "第8章 排序",
    "question": "排序趟数与序列的初始状态有关的排序算法是( )",
    "options": [
      {
        "label": "A",
        "text": "直接插入排序"
      },
      {
        "label": "B",
        "text": "二路归并排序"
      },
      {
        "label": "C",
        "text": "快速排序"
      },
      {
        "label": "D",
        "text": "堆排序"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 373,
    "chapter": "第8章 排序",
    "question": "对n 个元素进行排序, 其排序趟数肯定为n - 1 趟的排序算法是( )",
    "options": [
      {
        "label": "A",
        "text": "直接插入排序和快速排序"
      },
      {
        "label": "B",
        "text": "冒泡排序和快速排序"
      },
      {
        "label": "C",
        "text": "简单选择排序和直接插入排序"
      },
      {
        "label": "D",
        "text": "简单选择排序和冒泡排序"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 374,
    "chapter": "第8章 排序",
    "question": "若序列的原始状态为{1,2,3,4,5,10,6,7,8,9}, 要想使得排序过程中的元素比较次数最少, 则应该采 用( ) 方法。",
    "options": [
      {
        "label": "A",
        "text": "插入排序"
      },
      {
        "label": "B",
        "text": "选择排序"
      },
      {
        "label": "C",
        "text": "希尔排序"
      },
      {
        "label": "D",
        "text": "冒泡排序"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 375,
    "chapter": "第8章 排序",
    "question": "对于元素个数相同的不同初始序列,总比较次数相同的排序算法是( )",
    "options": [
      {
        "label": "A",
        "text": "折半插入排序和简单选择排序"
      },
      {
        "label": "B",
        "text": "基数排序和归并排序"
      },
      {
        "label": "C",
        "text": "冒泡排序和快速排序"
      },
      {
        "label": "D",
        "text": "堆排序"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 376,
    "chapter": "第8章 排序",
    "question": "一般情况下, 以下查找效率最低的数据结构是( )",
    "options": [
      {
        "label": "A",
        "text": "有序顺序表"
      },
      {
        "label": "B",
        "text": "二叉排序树"
      },
      {
        "label": "C",
        "text": "堆"
      },
      {
        "label": "D",
        "text": "平衡二叉树"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 377,
    "chapter": "第8章 排序",
    "question": "一台计算机具有多核CPU,可以同时执行相互独立的任务。归并排序的各个归并段可以并行执 行,在下列排序算法中, 不可以并行执行的有( ) IV.堆排序 I.基数排序 II.快速排序 III.冒泡排序",
    "options": [
      {
        "label": "A",
        "text": "I、III"
      },
      {
        "label": "B",
        "text": "I、II"
      },
      {
        "label": "C",
        "text": "I、II、IV"
      },
      {
        "label": "D",
        "text": "II、IV    13.【2009 统考真题】若数据元素序列{11,12,13,7,8,9,23,4,5} 是采用下列排序算法之一得到的第二 趟排序后的结果,则该排序算法只能是( ) C. 选择排序 D. 二路归并排序 A. 冒泡排序 B. 插入排序 14.【2010 统考真题】对一组数据(2,12,16,88,5,10) 进行排序, 若前3 趟排序结果如下:第一趟排序结果:2, 12, 16, 5, 10, 88 第二趟排序结果:2,12,5,10,16,88第三趟排序结果:2,5,10,12,16,88 则采用的排序算法可能是( ) C. 归并排序 D. 基数排序 A. 冒泡排序 B. 希尔排序 15.【2012 统考真题】在内部排序过程中, 对尚未确定最终位置的所有元素进行一遍处理称为一趟排 序。下列排序方法中, 每趟排序结束都至少能够确定一个元素最终位置的方法是( ) ) I.简单选择排序 II.希尔排序 III.快速排序 IV.堆排序 V.二路归并排序 A. 仅I、III、IV B. 仅I、III、V C. 仅II、III、IV D. 仅III、IV、V 16.【2017 统考真题】在内部排序时, 若选择了归并排序而未选择插入排序, 则可能的理由是( I. 归并排序的程序代码更短 II.归并排序的占用空间更少 III.归并排序的运行效率更高 A. 仅II B. 仅III C. 仅I、II D. 仅I、III 17.【2017 统考真题】下列排序方法中, 若将顺序存储更换为链式存储, 则算法的时间效率会降低的 是( ) ) I.插入排序 II.选择排序 III.起泡排序 IV.希尔排序 V.堆排序 A. 仅I、II B. 仅II、III C. 仅III、IV D. 仅IV、V 18.【2019 统考真题】选择一个排序算法时,除算法的时空效率外,下列因素中,还需要考虑的是( I.数据的规模 II.数据的存储方式 III.算法的稳定性 IV.数据的初始状态 A. 仅III B. 仅I、II C. 仅II、III、IV D. I、II、III、IV 19.【2020 统考真题】对大部分元素已有序的数组排序时,直接插入排序比简单选择排序效率更高,其原因是( ) I.直接插入排序过程中元素之间的比较次数更少II.直接插入排序过程中所需的辅助空间更少III.直接插入排序过程中元素的移动次数更少 A. 仅I B. 仅III C. 仅I、II D. I、II 和III    20.【2022 统考真题】对数据进行排序时,若采用直接插入排序而不采用快速排序,则可能的原因是( ) I.大部分元素已有序II.待排序元素数量很少III.要求空间复杂度为O 1 IV.要求排序算法是稳定的 A. 仅I、II B. 仅III、IV C. 仅I、II、IV D. I、II、III、IV 21.【2023 统考真题】下列排序算法中, 不稳定的是( ) I.希尔排序II.归并排序III.快速排序IV.堆排序V.基数排序 A. 仅I、II B. 仅II、V C. 仅I、III、IV D. 仅III、IV、V"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 378,
    "chapter": "第8章 排序",
    "question": "外部排序和内部排序的主要区别是( )",
    "options": [
      {
        "label": "A",
        "text": "内部排序的数据量小,而外部排序的数据量大"
      },
      {
        "label": "B",
        "text": "内部排序不涉及内、外存数据交换,而外部排序涉及内、外存数据交换"
      },
      {
        "label": "C",
        "text": "内部排序的速度快,而外部排序的速度慢"
      },
      {
        "label": "D",
        "text": "内部排序所需的内存小,而外部排序所需的内存大"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 379,
    "chapter": "第8章 排序",
    "question": "下列关于外部排序的说法中, 正确的是( )",
    "options": [
      {
        "label": "A",
        "text": "置换选择排序得到的初始归并段的长度一定相等"
      },
      {
        "label": "B",
        "text": "内外存交换数据的时间只占总排序时间的一小部分"
      },
      {
        "label": "C",
        "text": "败者树是一棵完全二叉树"
      },
      {
        "label": "D",
        "text": "外部排序不涉及对文件的读/ 写操作"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 380,
    "chapter": "第8章 排序",
    "question": "多路平衡归并的作用是( ) B. 减少初始归并段的个数",
    "options": [
      {
        "label": "A",
        "text": "减少归并趟数 C. 便于实现败者树 D. 以上都对 4. 设在磁盘上存放有375000 个记录,做5 路平衡归并排序,内存工作区能容纳600 个记录,为把所有记 录排好序, 需要做( ) 趟归并排序。 A. 3"
      },
      {
        "label": "B",
        "text": "4"
      },
      {
        "label": "C",
        "text": "5"
      },
      {
        "label": "D",
        "text": "6"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 381,
    "chapter": "第8章 排序",
    "question": "在下列关于外部排序过程输入/ 输出缓冲区作用的叙述中,不正确的是( )",
    "options": [
      {
        "label": "A",
        "text": "暂存输入/ 输出记录"
      },
      {
        "label": "B",
        "text": "内部归并的工作区"
      },
      {
        "label": "C",
        "text": "产生初始归并段的工作区"
      },
      {
        "label": "D",
        "text": "传送用户界面的消息"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 382,
    "chapter": "第8章 排序",
    "question": "在做m 路平衡归并排序的过程中, 为实现输入/ 内部归并/ 输出的并行处理, 需要设置(①) 个输入缓冲区和(②) 个输出缓冲区。 ①",
    "options": [
      {
        "label": "A",
        "text": "2"
      },
      {
        "label": "B",
        "text": "m"
      },
      {
        "label": "C",
        "text": "2m - 1"
      },
      {
        "label": "D",
        "text": "2m ②A. 2 B. m C. 2m - 1 D. 2m"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 383,
    "chapter": "第8章 排序",
    "question": "若只需3 趟排序就可完成64 个元素的多路归并排序,则选取的归并路数最少是( )",
    "options": [
      {
        "label": "A",
        "text": "2"
      },
      {
        "label": "B",
        "text": "3"
      },
      {
        "label": "C",
        "text": "4"
      },
      {
        "label": "D",
        "text": "5"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 384,
    "chapter": "第8章 排序",
    "question": "置换- 选择排序的作用是( )",
    "options": [
      {
        "label": "A",
        "text": "用于生成外部排序的初始归并段"
      },
      {
        "label": "B",
        "text": "完成将一个磁盘文件排序成有序文件的有效的外部排序算法"
      },
      {
        "label": "C",
        "text": "生成的初始归并段的长度是内存工作区的2 倍"
      },
      {
        "label": "D",
        "text": "对外部排序中输入/ 归并/ 输出的并行处理"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 385,
    "chapter": "第8章 排序",
    "question": "一个无序文件的n 个记录采用置换选择排序产生m 个有序段, 则m 和n 的关系是( )",
    "options": [
      {
        "label": "A",
        "text": "m 与n 成正比"
      },
      {
        "label": "B",
        "text": "m = log2n"
      },
      {
        "label": "C",
        "text": "m 与n 成反比"
      },
      {
        "label": "D",
        "text": "以上都不对"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 386,
    "chapter": "第8章 排序",
    "question": "在由k 路归并构建的败者树中选取一个关键字最小的记录, 则所需时间为( )",
    "options": [
      {
        "label": "A",
        "text": "O 1"
      },
      {
        "label": "B",
        "text": "O k"
      },
      {
        "label": "C",
        "text": "O log2k"
      },
      {
        "label": "D",
        "text": "以上都不对"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 387,
    "chapter": "第8章 排序",
    "question": "下列关于小顶堆和败者树的说法中, 正确的是( ) I.败者树从下往上维护,每上一层,只需和失败结点比较1 次II.败者树的每次维护,必定要从叶结点一直走到根结点,不可能从中间停止III.堆从上往下维护, 每下一层, 若其左右孩子均不为空, 则需比较2 次IV.堆的每次维护,必定要从根结点一直走到叶结点,不可能从中间停止",
    "options": [
      {
        "label": "A",
        "text": "I、III"
      },
      {
        "label": "B",
        "text": "II、III"
      },
      {
        "label": "C",
        "text": "I、II、III"
      },
      {
        "label": "D",
        "text": "I、III、IV )"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 388,
    "chapter": "第8章 排序",
    "question": "最佳归并树在外部排序中的作用是( )",
    "options": [
      {
        "label": "A",
        "text": "完成m 路归并排序"
      },
      {
        "label": "B",
        "text": "设计m 路归并排序的优化方案"
      },
      {
        "label": "C",
        "text": "产生初始归并段"
      },
      {
        "label": "D",
        "text": "与锦标赛树的作用类似"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  },
  {
    "id": 389,
    "chapter": "第8章 排序",
    "question": "在由m 个初始归并段构建的k 阶最佳归并树中, 不需要补充虚段, 则度为k 的结点个数是(",
    "options": [
      {
        "label": "A",
        "text": " m-1 /k"
      },
      {
        "label": "B",
        "text": "m/k"
      },
      {
        "label": "C",
        "text": " m-1 / k-1"
      },
      {
        "label": "D",
        "text": "无法确定 14.【2013 统考真题】已知三叉树T 中6 个叶结点的权分别是2,3,4,5,6,7, T 的带权(外部) 路径长度 最小是( ) D. 56 ) D. 归并排序 A. 27 B. 46 C. 54 15.【2016 统考真题】对10TB 的数据文件进行排序,应使用的方法是( A. 希尔排序 B. 堆排序 C. 快速排序 16.【2019 统考真题】设外存上有120 个初始归并段,进行12 路归并时,为实现最佳归并,需要补充的 虚段个数是( ) B. 2 C. 3 D. 4 A. 1    17.【2024 统考真题】在外排序中,利用败者树对初始为升序的归并段进行多路归并,败者树中记录 “冠军”的结点保存的是( ) B. 最小关键字D. 最小关键字所在的归并段号 A. 最大关键字C. 最大关键字所在的归并段号"
      }
    ],
    "answer": null,
    "subject": "数据结构"
  }
]