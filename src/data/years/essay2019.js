// 2019年408真题大题数据

export const essay2019 = [
  {
    id: 41,
    subject: 'ds',
    title: '链表重排',
    score: 15,
    question: `设线性表L=(a1,a2,a3,...,an-1,an)采用带头结点的单链表保存，链表中的结点定义如下：
typedef struct node {
    int data;
    struct node *next;
} NODE;

请设计一个空间复杂度为O(1)且时间上尽可能高效的算法，重新排列L中的各结点，得到线性表L'=(a1,an,a2,an-1,a3,an-2,...)。`,
    answer: `【设计思想】
观察L和L'，发现L'是由L摘取第一个元素，再摘取倒数第一个元素...依次合并而成的。为了方便链表后半段取元素，需要先将L后半段原地逆置。

①先找出链表L的中间结点，设置两个指针p和q，p每次走一步，q每次走两步，当q到达链尾时，p正好在中间结点；
②然后将L的后半段结点原地逆置；
③从单链表前后两段中依次各取一个结点，按要求重排。

【算法实现】
void solve(NODE *head) {
    if (head->next == NULL) return;
    NODE *middle = findMiddleNode(head);
    NODE *list2 = reverse(middle);
    NODE *list1 = head->next;
    // 穿插操作
    NODE *p = list1, *q = list2;
    while (p != q && p->next != q) {
        NODE *tmp1 = p->next, *tmp2 = q->next;
        p->next = q; q->next = tmp1;
        p = tmp1; q = tmp2;
    }
}

时间复杂度O(n)，空间复杂度O(1)。`,
    tags: ['链表', '双指针', '原地逆置']
  },
  {
    id: 42,
    subject: 'ds',
    title: '循环链式队列设计',
    score: 8,
    question: `请设计一个队列，要求满足：
①初始时队列为空；
②入队时，允许增加队列占用空间；
③出队后，出队元素所占用的空间可重复使用，即整个队列所占用的空间只增不减；
④入队操作和出队操作的时间复杂度始终保持为O(1)。
请回答：
(1) 该队列是应选择链式存储结构，还是应选择顺序存储结构？
(2) 画出队列的初始状态，并给出判断队空和队满的条件。
(3) 给出入队操作和出队操作的基本过程。`,
    answer: `(1) 采用链式存储结构（两段式单向循环链表），队头指针为front，队尾指针为rear。
顺序存储无法满足队列占用空间随着入队操作而增加的要求。

(2) 初始时，创建只有一个空闲结点的循环单链表，头指针front和尾指针rear均指向空闲结点。
队空的判定条件：front == rear
队满的判定条件：front == rear->next

(3) 入队操作：
if (front == rear->next)
    则在rear后面插入一个新的空闲结点；
入队元素保存到rear所指结点中；
rear = rear->next；返回。

出队操作：
if (front == rear) // 队空
    则出队失败，返回；
取front所指结点中的元素e；
front = front->next；返回e。`,
    tags: ['队列', '循环链表', '数据结构设计']
  },
  {
    id: 43,
    subject: 'os',
    title: '哲学家就餐问题变形',
    score: 7,
    question: `有n(n≥3)位哲学家围坐在一张圆桌边，每位哲学家交替地就餐和思考。在圆桌中心有m(m≥1)个碗，每两位哲学家之间有一根筷子。每位哲学家必须取到一个碗和两侧的筷子后，才能就餐，进餐完毕，将碗和筷子放回原位，并继续思考。
为使尽可能多的哲学家同时就餐，且防止出现死锁现象，请使用信号量的P、V操作描述上述过程中的互斥与同步，并说明所用信号量及初值的含义。`,
    answer: `【分析】
用碗这个限制资源来避免死锁：当碗的数量m小于哲学家的数量n时，可以直接让碗的资源量等于m；当碗的数量大于等于哲学家的数量时，让碗的资源量等于n-1，这样就能保证最多只有n-1个哲学家同时进餐。

【信号量定义】
semaphore fork[n] = {1};  // 每根筷子的信号量
semaphore plate = min(m, n-1);  // 碗的信号量，限制并发数量

【同步过程】
philosopher(int i) {
    while (1) {
        think();
        P(plate);           // 先获取碗
        P(fork[i]);         // 获取左边筷子
        P(fork[(i+1) % n]); // 获取右边筷子
        eat();
        V(fork[i]);         // 放下左边筷子
        V(fork[(i+1) % n]); // 放下右边筷子
        V(plate);           // 放下碗
    }
}`,
    tags: ['哲学家就餐', '信号量', '死锁预防']
  },
  {
    id: 44,
    subject: 'os',
    title: '磁盘调度与地址转换',
    score: 8,
    question: `某计算机系统中的磁盘有300个柱面，每个柱面有10个磁道，每个磁道有200个扇区，扇区大小为512B。文件系统的每个簇包含2个扇区。
(1) 磁盘的容量是多少？
(2) 假设磁头在85号柱面上，此时有4个磁盘访问请求，簇号分别为100260、60005、101660和110560。若采用最短寻道时间优先(SSTF)调度算法，则系统访问簇的先后次序是什么？
(3) 第100530簇在磁盘上的物理地址是什么？将簇号转换成磁盘物理地址的过程是由I/O系统的什么程序完成的？`,
    answer: `(1) 磁盘容量 = 柱面数 × 每个柱面的磁道数 × 每个磁道的扇区数 × 每个扇区的大小
= 300 × 10 × 200 × 512B = 300000KB ≈ 293MB

(2) 85号柱面对应的簇号为85000～85999。
按SSTF算法，总是访问当前柱面距离最近的地址：
- 最先访问离85000～85999最近的100260
- 随后访问离100260最近的101660
- 然后访问110560
- 最后访问60005
顺序为：100260、101660、110560、60005

(3) 第100530簇在磁盘上的物理地址：
柱面号 = ⌊100530/(10×200/2)⌋ = ⌊100530/1000⌋ = 100
磁道号 = ⌊(100530%1000)/(200/2)⌋ = ⌊530/100⌋ = 5
扇区号 = (530×2) % 200 = 60

将簇号转换成磁盘物理地址的过程由磁盘驱动程序完成。`,
    tags: ['磁盘调度', 'SSTF', 'CHS地址']
  },
  {
    id: 45,
    subject: 'co',
    title: '递归函数机器级代码分析',
    score: 13,
    question: `已知f(n)=n!=n×(n-1)×(n-2)×...×2×1，计算f(n)的C语言函数f1的源程序及其在32位计算机M上的部分机器级代码如题所示。
(1) 计算f(10)需要调用函数f1多少次？执行哪条指令会递归调用f1？
(2) 上述代码中，哪条指令是条件转移指令？哪几条指令一定会使程序跳转执行？
(3) 根据第16行的call指令，第17行指令的虚拟地址应是多少？该指令中的偏移量应是多少？M是采用大端方式还是小端方式？
(4) f(13)=6227020800，但f1(13)的返回值为1932053504，为什么两者不相等？
(5) 第19行的imul指令的功能是R[eax]←R[eax]×R[ecx]，当乘法器输出的高、低32位乘积之间满足什么条件时，溢出标志OF=1？`,
    answer: `(1) 计算f(10)需要调用函数f1共10次。执行第16行的call指令会递归调用f1。

(2) 第12行的jle指令是条件转移指令（小于等于时转移）。
第16行的call指令、第20行的jmp指令、第30行的ret指令一定会使程序跳转执行。

(3) 第16行call指令的虚拟地址为00401025H，长度为5字节。
第17行指令的虚拟地址 = 00401025H + 5 = 0040102AH
偏移量 = 目标地址 - (PC) = 00401000H - 0040102AH = FFFFFFD6H
根据call指令的偏移量字段为D6 FF FF FF，可确定M采用小端方式。

(4) 因为f(13)=6227020800，其结果超出了32位int型数据可表示的最大范围，因此f1(13)的返回值是一个发生了溢出的错误结果。
可将函数f1的返回值类型改为long long或double类型。

(5) 若乘积的高33位为非全0或非全1，则OF=1。
编译器应在imul指令后加一条"溢出自陷指令"。`,
    tags: ['汇编代码', '递归', '溢出']
  },
  {
    id: 46,
    subject: 'co',
    title: 'Cache组相联映射分析',
    score: 8,
    question: `对于上题，若计算机M的主存地址为32位，采用分页存储管理方式，页大小为4KB，则第1行的push指令和第30行的ret指令是否在同一页中？
若指令Cache有64行，采用4路组相联映射方式，主存块大小为64B，则32位主存地址中，哪几位表示块内地址？哪几位表示Cache组号？哪几位表示标记(tag)信息？
读取第16行的call指令时，只可能在指令Cache的哪一组中命中？`,
    answer: `因为页大小为4KB，所以虚拟地址的高20位为虚拟页号。
第1行的push指令和第30行的ret指令的虚拟地址的高20位都是00401H，因此两条指令在同一页中。

指令Cache有64块，采用4路组相联映射方式，故指令Cache共有64/4=16组，Cache组号共4位。
主存块大小为64B，故块内地址为低6位。

在32位主存地址中：
- 低6位为块内地址
- 中间4位为组号
- 高22位为标记

因为页大小为4KB，所以虚拟地址和物理地址的最低12位完全相同。
call指令虚拟地址00401025H中的025H=0000 0010 0101B为物理地址的低12位，对应的7～10位为组号。
故对应的Cache组号为0，只可能在第0组中命中。`,
    tags: ['Cache', '组相联映射', '分页']
  },
  {
    id: 47,
    subject: 'cn',
    title: '网络设备选择与NAT',
    score: 9,
    question: `某网络拓扑如图所示，其中R为路由器，主机H1~H4的IP地址配置以及R的各接口IP地址配置如图中所示。现有若干台以太网交换机（无VLAN功能）和路由器两类网络互连设备可供选择。
(1) 设备1、设备2和设备3分别应选择什么类型网络设备？
(2) 设备1、设备2和设备3中，哪几个设备的接口需要配置IP地址？并为对应的接口配置正确的IP地址。
(3) 为确保主机H1~H4能够访问Internet，R需要提供什么服务？
(4) 若主机H3发送一个目的地址为192.168.1.127的IP数据报，网络中哪几个主机会接收该数据报？`,
    answer: `(1) 以太网交换机连接的若干LAN仍然是一个网络（同一个广播域），路由器可以连接不同的LAN，隔离广播域。
IP地址192.168.1.2/26与192.168.1.3/26的网络前缀均为192.168.1.0，视为LAN1。
IP地址192.168.1.66/26与192.168.1.67/26的网络前缀均为192.168.1.64，视为LAN2。
所以设备1为路由器，设备2、3为以太网交换机。

(2) 设备1为路由器，其接口应配置IP地址。
IF1接口的IP地址应为192.168.1.254（与R相连）
IF2接口的IP地址应为192.168.1.1（LAN1的默认网关）
IF3接口的IP地址应为192.168.1.65（LAN2的默认网关）

(3) H1～H4均为私有IP地址，若要能够访问Internet，R需要提供NAT服务（网络地址转换服务）。

(4) 192.168.1.127的主机号全为1，为本网络的广播地址。由于路由器可以隔离广播域，只有主机H4会接收到数据报。`,
    tags: ['网络设备', 'NAT', '广播域']
  }
];

export default essay2019;
